(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".rg-input{position:absolute;top:0;left:0;resize:none;overflow-y:hidden;box-sizing:border-box;text-align:center;width:100%;height:100%;background:transparent;border:none;padding:0;outline:none;color:inherit;font-size:inherit;font-family:inherit}")),document.head.appendChild(e)}}catch(n){console.error("vite-plugin-css-injected-by-js",n)}})();
var Ji = Object.defineProperty;
var Zi = (e, t, r) => t in e ? Ji(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Lo = (e, t, r) => (Zi(e, typeof t != "symbol" ? t + "" : t, r), r);
import * as vr from "react/jsx-runtime";
import * as ft from "react";
import Yt, { forwardRef as Qi, useContext as pi, Component as ea, useRef as qe, useState as Kt, useEffect as Te, createContext as gi, memo as ta, useCallback as na, useMemo as ra } from "react";
var oa = !1;
function ia(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function aa(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var la = /* @__PURE__ */ function() {
  function e(r) {
    var n = this;
    this._insertTag = function(i) {
      var a;
      n.tags.length === 0 ? n.insertionPoint ? a = n.insertionPoint.nextSibling : n.prepend ? a = n.container.firstChild : a = n.before : a = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(i, a), n.tags.push(i);
    }, this.isSpeedy = r.speedy === void 0 ? !oa : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(aa(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = ia(i);
      try {
        a.insertRule(n, a.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      var i;
      return (i = n.parentNode) == null ? void 0 : i.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), ve = "-ms-", Wr = "-moz-", ee = "-webkit-", wi = "comm", mo = "rule", So = "decl", da = "@import", Ci = "@keyframes", sa = "@layer", ca = Math.abs, Yr = String.fromCharCode, ua = Object.assign;
function fa(e, t) {
  return Se(e, 0) ^ 45 ? (((t << 2 ^ Se(e, 0)) << 2 ^ Se(e, 1)) << 2 ^ Se(e, 2)) << 2 ^ Se(e, 3) : 0;
}
function Ri(e) {
  return e.trim();
}
function xa(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function te(e, t, r) {
  return e.replace(t, r);
}
function co(e, t) {
  return e.indexOf(t);
}
function Se(e, t) {
  return e.charCodeAt(t) | 0;
}
function br(e, t, r) {
  return e.slice(t, r);
}
function ct(e) {
  return e.length;
}
function yo(e) {
  return e.length;
}
function Pr(e, t) {
  return t.push(e), e;
}
function Ia(e, t) {
  return e.map(t).join("");
}
var qr = 1, zn = 1, mi = 0, Oe = 0, he = 0, Un = "";
function Xr(e, t, r, n, i, a, d) {
  return { value: e, root: t, parent: r, type: n, props: i, children: a, line: qr, column: zn, length: d, return: "" };
}
function Sr(e, t) {
  return ua(Xr("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function ha() {
  return he;
}
function pa() {
  return he = Oe > 0 ? Se(Un, --Oe) : 0, zn--, he === 10 && (zn = 1, qr--), he;
}
function Fe() {
  return he = Oe < mi ? Se(Un, Oe++) : 0, zn++, he === 10 && (zn = 1, qr++), he;
}
function xt() {
  return Se(Un, Oe);
}
function zr() {
  return Oe;
}
function Er(e, t) {
  return br(Un, e, t);
}
function Ar(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Si(e) {
  return qr = zn = 1, mi = ct(Un = e), Oe = 0, [];
}
function yi(e) {
  return Un = "", e;
}
function jr(e) {
  return Ri(Er(Oe - 1, uo(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function ga(e) {
  for (; (he = xt()) && he < 33; )
    Fe();
  return Ar(e) > 2 || Ar(he) > 3 ? "" : " ";
}
function wa(e, t) {
  for (; --t && Fe() && !(he < 48 || he > 102 || he > 57 && he < 65 || he > 70 && he < 97); )
    ;
  return Er(e, zr() + (t < 6 && xt() == 32 && Fe() == 32));
}
function uo(e) {
  for (; Fe(); )
    switch (he) {
      case e:
        return Oe;
      case 34:
      case 39:
        e !== 34 && e !== 39 && uo(he);
        break;
      case 40:
        e === 41 && uo(e);
        break;
      case 92:
        Fe();
        break;
    }
  return Oe;
}
function Ca(e, t) {
  for (; Fe() && e + he !== 47 + 10; )
    if (e + he === 42 + 42 && xt() === 47)
      break;
  return "/*" + Er(t, Oe - 1) + "*" + Yr(e === 47 ? e : Fe());
}
function Ra(e) {
  for (; !Ar(xt()); )
    Fe();
  return Er(e, Oe);
}
function ma(e) {
  return yi(Nr("", null, null, null, [""], e = Si(e), 0, [0], e));
}
function Nr(e, t, r, n, i, a, d, u, I) {
  for (var x = 0, h = 0, f = d, C = 0, m = 0, S = 0, p = 1, R = 1, v = 1, y = 0, _ = "", A = i, w = a, E = n, L = _; R; )
    switch (S = y, y = Fe()) {
      case 40:
        if (S != 108 && Se(L, f - 1) == 58) {
          co(L += te(jr(y), "&", "&\f"), "&\f") != -1 && (v = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        L += jr(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        L += ga(S);
        break;
      case 92:
        L += wa(zr() - 1, 7);
        continue;
      case 47:
        switch (xt()) {
          case 42:
          case 47:
            Pr(Sa(Ca(Fe(), zr()), t, r), I);
            break;
          default:
            L += "/";
        }
        break;
      case 123 * p:
        u[x++] = ct(L) * v;
      case 125 * p:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            R = 0;
          case 59 + h:
            v == -1 && (L = te(L, /\f/g, "")), m > 0 && ct(L) - f && Pr(m > 32 ? Oo(L + ";", n, r, f - 1) : Oo(te(L, " ", "") + ";", n, r, f - 2), I);
            break;
          case 59:
            L += ";";
          default:
            if (Pr(E = Bo(L, t, r, x, h, i, u, _, A = [], w = [], f), a), y === 123)
              if (h === 0)
                Nr(L, t, E, E, A, a, f, u, w);
              else
                switch (C === 99 && Se(L, 3) === 110 ? 100 : C) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Nr(e, E, E, n && Pr(Bo(e, E, E, 0, 0, i, u, _, i, A = [], f), w), i, w, f, u, n ? A : w);
                    break;
                  default:
                    Nr(L, E, E, E, [""], w, 0, u, w);
                }
        }
        x = h = m = 0, p = v = 1, _ = L = "", f = d;
        break;
      case 58:
        f = 1 + ct(L), m = S;
      default:
        if (p < 1) {
          if (y == 123)
            --p;
          else if (y == 125 && p++ == 0 && pa() == 125)
            continue;
        }
        switch (L += Yr(y), y * p) {
          case 38:
            v = h > 0 ? 1 : (L += "\f", -1);
            break;
          case 44:
            u[x++] = (ct(L) - 1) * v, v = 1;
            break;
          case 64:
            xt() === 45 && (L += jr(Fe())), C = xt(), h = f = ct(_ = L += Ra(zr())), y++;
            break;
          case 45:
            S === 45 && ct(L) == 2 && (p = 0);
        }
    }
  return a;
}
function Bo(e, t, r, n, i, a, d, u, I, x, h) {
  for (var f = i - 1, C = i === 0 ? a : [""], m = yo(C), S = 0, p = 0, R = 0; S < n; ++S)
    for (var v = 0, y = br(e, f + 1, f = ca(p = d[S])), _ = e; v < m; ++v)
      (_ = Ri(p > 0 ? C[v] + " " + y : te(y, /&\f/g, C[v]))) && (I[R++] = _);
  return Xr(e, t, r, i === 0 ? mo : u, I, x, h);
}
function Sa(e, t, r) {
  return Xr(e, t, r, wi, Yr(ha()), br(e, 2, -2), 0);
}
function Oo(e, t, r, n) {
  return Xr(e, t, r, So, br(e, 0, n), br(e, n + 1, -1), n);
}
function Hn(e, t) {
  for (var r = "", n = yo(e), i = 0; i < n; i++)
    r += t(e[i], i, e, t) || "";
  return r;
}
function ya(e, t, r, n) {
  switch (e.type) {
    case sa:
      if (e.children.length)
        break;
    case da:
    case So:
      return e.return = e.return || e.value;
    case wi:
      return "";
    case Ci:
      return e.return = e.value + "{" + Hn(e.children, n) + "}";
    case mo:
      e.value = e.props.join(",");
  }
  return ct(r = Hn(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function va(e) {
  var t = yo(e);
  return function(r, n, i, a) {
    for (var d = "", u = 0; u < t; u++)
      d += e[u](r, n, i, a) || "";
    return d;
  };
}
function ba(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function Aa(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] === void 0 && (t[r] = e(r)), t[r];
  };
}
var _a = function(t, r, n) {
  for (var i = 0, a = 0; i = a, a = xt(), i === 38 && a === 12 && (r[n] = 1), !Ar(a); )
    Fe();
  return Er(t, Oe);
}, Ta = function(t, r) {
  var n = -1, i = 44;
  do
    switch (Ar(i)) {
      case 0:
        i === 38 && xt() === 12 && (r[n] = 1), t[n] += _a(Oe - 1, r, n);
        break;
      case 2:
        t[n] += jr(i);
        break;
      case 4:
        if (i === 44) {
          t[++n] = xt() === 58 ? "&\f" : "", r[n] = t[n].length;
          break;
        }
      default:
        t[n] += Yr(i);
    }
  while (i = Fe());
  return t;
}, Ea = function(t, r) {
  return yi(Ta(Si(t), r));
}, Po = /* @__PURE__ */ new WeakMap(), La = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var r = t.value, n = t.parent, i = t.column === n.column && t.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n)
        return;
    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !Po.get(n)) && !i) {
      Po.set(t, !0);
      for (var a = [], d = Ea(r, a), u = n.props, I = 0, x = 0; I < d.length; I++)
        for (var h = 0; h < u.length; h++, x++)
          t.props[x] = a[I] ? d[I].replace(/&\f/g, u[h]) : u[h] + " " + d[I];
    }
  }
}, Ba = function(t) {
  if (t.type === "decl") {
    var r = t.value;
    // charcode for l
    r.charCodeAt(0) === 108 && // charcode for b
    r.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function vi(e, t) {
  switch (fa(e, t)) {
    case 5103:
      return ee + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ee + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ee + e + Wr + e + ve + e + e;
    case 6828:
    case 4268:
      return ee + e + ve + e + e;
    case 6165:
      return ee + e + ve + "flex-" + e + e;
    case 5187:
      return ee + e + te(e, /(\w+).+(:[^]+)/, ee + "box-$1$2" + ve + "flex-$1$2") + e;
    case 5443:
      return ee + e + ve + "flex-item-" + te(e, /flex-|-self/, "") + e;
    case 4675:
      return ee + e + ve + "flex-line-pack" + te(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return ee + e + ve + te(e, "shrink", "negative") + e;
    case 5292:
      return ee + e + ve + te(e, "basis", "preferred-size") + e;
    case 6060:
      return ee + "box-" + te(e, "-grow", "") + ee + e + ve + te(e, "grow", "positive") + e;
    case 4554:
      return ee + te(e, /([^-])(transform)/g, "$1" + ee + "$2") + e;
    case 6187:
      return te(te(te(e, /(zoom-|grab)/, ee + "$1"), /(image-set)/, ee + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return te(e, /(image-set\([^]*)/, ee + "$1$`$1");
    case 4968:
      return te(te(e, /(.+:)(flex-)?(.*)/, ee + "box-pack:$3" + ve + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ee + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return te(e, /(.+)-inline(.+)/, ee + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ct(e) - 1 - t > 6)
        switch (Se(e, t + 1)) {
          case 109:
            if (Se(e, t + 4) !== 45)
              break;
          case 102:
            return te(e, /(.+:)(.+)-([^]+)/, "$1" + ee + "$2-$3$1" + Wr + (Se(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~co(e, "stretch") ? vi(te(e, "stretch", "fill-available"), t) + e : e;
        }
      break;
    case 4949:
      if (Se(e, t + 1) !== 115)
        break;
    case 6444:
      switch (Se(e, ct(e) - 3 - (~co(e, "!important") && 10))) {
        case 107:
          return te(e, ":", ":" + ee) + e;
        case 101:
          return te(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ee + (Se(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ee + "$2$3$1" + ve + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (Se(e, t + 11)) {
        case 114:
          return ee + e + ve + te(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return ee + e + ve + te(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return ee + e + ve + te(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ee + e + ve + e + e;
  }
  return e;
}
var Oa = function(t, r, n, i) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case So:
        t.return = vi(t.value, t.length);
        break;
      case Ci:
        return Hn([Sr(t, {
          value: te(t.value, "@", "@" + ee)
        })], i);
      case mo:
        if (t.length)
          return Ia(t.props, function(a) {
            switch (xa(a, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return Hn([Sr(t, {
                  props: [te(a, /:(read-\w+)/, ":" + Wr + "$1")]
                })], i);
              case "::placeholder":
                return Hn([Sr(t, {
                  props: [te(a, /:(plac\w+)/, ":" + ee + "input-$1")]
                }), Sr(t, {
                  props: [te(a, /:(plac\w+)/, ":" + Wr + "$1")]
                }), Sr(t, {
                  props: [te(a, /:(plac\w+)/, ve + "input-$1")]
                })], i);
            }
            return "";
          });
    }
}, Pa = [Oa], $a = function(t) {
  var r = t.key;
  if (r === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(p) {
      var R = p.getAttribute("data-emotion");
      R.indexOf(" ") !== -1 && (document.head.appendChild(p), p.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || Pa, a = {}, d, u = [];
  d = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
    function(p) {
      for (var R = p.getAttribute("data-emotion").split(" "), v = 1; v < R.length; v++)
        a[R[v]] = !0;
      u.push(p);
    }
  );
  var I, x = [La, Ba];
  {
    var h, f = [ya, ba(function(p) {
      h.insert(p);
    })], C = va(x.concat(i, f)), m = function(R) {
      return Hn(ma(R), C);
    };
    I = function(R, v, y, _) {
      h = y, m(R ? R + "{" + v.styles + "}" : v.styles), _ && (S.inserted[v.name] = !0);
    };
  }
  var S = {
    key: r,
    sheet: new la({
      key: r,
      container: d,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: I
  };
  return S.sheet.hydrate(u), S;
}, Ye = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fo = { exports: {} }, ne = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $o;
function Da() {
  if ($o)
    return ne;
  $o = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, d = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, I = e ? Symbol.for("react.async_mode") : 60111, x = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, C = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, S = e ? Symbol.for("react.lazy") : 60116, p = e ? Symbol.for("react.block") : 60121, R = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function _(w) {
    if (typeof w == "object" && w !== null) {
      var E = w.$$typeof;
      switch (E) {
        case t:
          switch (w = w.type, w) {
            case I:
            case x:
            case n:
            case a:
            case i:
            case f:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case u:
                case h:
                case S:
                case m:
                case d:
                  return w;
                default:
                  return E;
              }
          }
        case r:
          return E;
      }
    }
  }
  function A(w) {
    return _(w) === x;
  }
  return ne.AsyncMode = I, ne.ConcurrentMode = x, ne.ContextConsumer = u, ne.ContextProvider = d, ne.Element = t, ne.ForwardRef = h, ne.Fragment = n, ne.Lazy = S, ne.Memo = m, ne.Portal = r, ne.Profiler = a, ne.StrictMode = i, ne.Suspense = f, ne.isAsyncMode = function(w) {
    return A(w) || _(w) === I;
  }, ne.isConcurrentMode = A, ne.isContextConsumer = function(w) {
    return _(w) === u;
  }, ne.isContextProvider = function(w) {
    return _(w) === d;
  }, ne.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, ne.isForwardRef = function(w) {
    return _(w) === h;
  }, ne.isFragment = function(w) {
    return _(w) === n;
  }, ne.isLazy = function(w) {
    return _(w) === S;
  }, ne.isMemo = function(w) {
    return _(w) === m;
  }, ne.isPortal = function(w) {
    return _(w) === r;
  }, ne.isProfiler = function(w) {
    return _(w) === a;
  }, ne.isStrictMode = function(w) {
    return _(w) === i;
  }, ne.isSuspense = function(w) {
    return _(w) === f;
  }, ne.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === n || w === x || w === a || w === i || w === f || w === C || typeof w == "object" && w !== null && (w.$$typeof === S || w.$$typeof === m || w.$$typeof === d || w.$$typeof === u || w.$$typeof === h || w.$$typeof === R || w.$$typeof === v || w.$$typeof === y || w.$$typeof === p);
  }, ne.typeOf = _, ne;
}
var re = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Do;
function Ma() {
  return Do || (Do = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, d = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, I = e ? Symbol.for("react.async_mode") : 60111, x = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, C = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, S = e ? Symbol.for("react.lazy") : 60116, p = e ? Symbol.for("react.block") : 60121, R = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function _($) {
      return typeof $ == "string" || typeof $ == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      $ === n || $ === x || $ === a || $ === i || $ === f || $ === C || typeof $ == "object" && $ !== null && ($.$$typeof === S || $.$$typeof === m || $.$$typeof === d || $.$$typeof === u || $.$$typeof === h || $.$$typeof === R || $.$$typeof === v || $.$$typeof === y || $.$$typeof === p);
    }
    function A($) {
      if (typeof $ == "object" && $ !== null) {
        var at = $.$$typeof;
        switch (at) {
          case t:
            var ze = $.type;
            switch (ze) {
              case I:
              case x:
              case n:
              case a:
              case i:
              case f:
                return ze;
              default:
                var gt = ze && ze.$$typeof;
                switch (gt) {
                  case u:
                  case h:
                  case S:
                  case m:
                  case d:
                    return gt;
                  default:
                    return at;
                }
            }
          case r:
            return at;
        }
      }
    }
    var w = I, E = x, L = u, j = d, F = t, W = h, Y = n, T = S, B = m, H = r, M = a, V = i, Q = f, be = !1;
    function Xe($) {
      return be || (be = !0), q($) || A($) === I;
    }
    function q($) {
      return A($) === x;
    }
    function Jt($) {
      return A($) === u;
    }
    function Zt($) {
      return A($) === d;
    }
    function K($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === t;
    }
    function ht($) {
      return A($) === h;
    }
    function Z($) {
      return A($) === n;
    }
    function He($) {
      return A($) === S;
    }
    function Lt($) {
      return A($) === m;
    }
    function pe($) {
      return A($) === r;
    }
    function pt($) {
      return A($) === a;
    }
    function ot($) {
      return A($) === i;
    }
    function it($) {
      return A($) === f;
    }
    re.AsyncMode = w, re.ConcurrentMode = E, re.ContextConsumer = L, re.ContextProvider = j, re.Element = F, re.ForwardRef = W, re.Fragment = Y, re.Lazy = T, re.Memo = B, re.Portal = H, re.Profiler = M, re.StrictMode = V, re.Suspense = Q, re.isAsyncMode = Xe, re.isConcurrentMode = q, re.isContextConsumer = Jt, re.isContextProvider = Zt, re.isElement = K, re.isForwardRef = ht, re.isFragment = Z, re.isLazy = He, re.isMemo = Lt, re.isPortal = pe, re.isProfiler = pt, re.isStrictMode = ot, re.isSuspense = it, re.isValidElementType = _, re.typeOf = A;
  }()), re;
}
process.env.NODE_ENV === "production" ? fo.exports = Da() : fo.exports = Ma();
var Fa = fo.exports, bi = Fa, Ha = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, za = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Ai = {};
Ai[bi.ForwardRef] = Ha;
Ai[bi.Memo] = za;
var ja = !0;
function Na(e, t, r) {
  var n = "";
  return r.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : n += i + " ";
  }), n;
}
var _i = function(t, r, n) {
  var i = t.key + "-" + r.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  ja === !1) && t.registered[i] === void 0 && (t.registered[i] = r.styles);
}, Ga = function(t, r, n) {
  _i(t, r, n);
  var i = t.key + "-" + r.name;
  if (t.inserted[r.name] === void 0) {
    var a = r;
    do
      t.insert(r === a ? "." + i : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function Ua(e) {
  for (var t = 0, r, n = 0, i = e.length; i >= 4; ++n, i -= 4)
    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(n + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(n + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Wa = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, ka = !1, Ka = /[A-Z]|^ms/g, Va = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Ti = function(t) {
  return t.charCodeAt(1) === 45;
}, Mo = function(t) {
  return t != null && typeof t != "boolean";
}, eo = /* @__PURE__ */ Aa(function(e) {
  return Ti(e) ? e : e.replace(Ka, "-$&").toLowerCase();
}), Fo = function(t, r) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof r == "string")
        return r.replace(Va, function(n, i, a) {
          return ut = {
            name: i,
            styles: a,
            next: ut
          }, i;
        });
  }
  return Wa[t] !== 1 && !Ti(t) && typeof r == "number" && r !== 0 ? r + "px" : r;
}, Ya = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function _r(e, t, r) {
  if (r == null)
    return "";
  var n = r;
  if (n.__emotion_styles !== void 0)
    return n;
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      var i = r;
      if (i.anim === 1)
        return ut = {
          name: i.name,
          styles: i.styles,
          next: ut
        }, i.name;
      var a = r;
      if (a.styles !== void 0) {
        var d = a.next;
        if (d !== void 0)
          for (; d !== void 0; )
            ut = {
              name: d.name,
              styles: d.styles,
              next: ut
            }, d = d.next;
        var u = a.styles + ";";
        return u;
      }
      return qa(e, t, r);
    }
    case "function": {
      if (e !== void 0) {
        var I = ut, x = r(e);
        return ut = I, _r(e, t, x);
      }
      break;
    }
  }
  var h = r;
  if (t == null)
    return h;
  var f = t[h];
  return f !== void 0 ? f : h;
}
function qa(e, t, r) {
  var n = "";
  if (Array.isArray(r))
    for (var i = 0; i < r.length; i++)
      n += _r(e, t, r[i]) + ";";
  else
    for (var a in r) {
      var d = r[a];
      if (typeof d != "object") {
        var u = d;
        t != null && t[u] !== void 0 ? n += a + "{" + t[u] + "}" : Mo(u) && (n += eo(a) + ":" + Fo(a, u) + ";");
      } else {
        if (a === "NO_COMPONENT_SELECTOR" && ka)
          throw new Error(Ya);
        if (Array.isArray(d) && typeof d[0] == "string" && (t == null || t[d[0]] === void 0))
          for (var I = 0; I < d.length; I++)
            Mo(d[I]) && (n += eo(a) + ":" + Fo(a, d[I]) + ";");
        else {
          var x = _r(e, t, d);
          switch (a) {
            case "animation":
            case "animationName": {
              n += eo(a) + ":" + x + ";";
              break;
            }
            default:
              n += a + "{" + x + "}";
          }
        }
      }
    }
  return n;
}
var Ho = /label:\s*([^\s;\n{]+)\s*(;|$)/g, ut;
function Ei(e, t, r) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var n = !0, i = "";
  ut = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    n = !1, i += _r(r, t, a);
  else {
    var d = a;
    i += d[0];
  }
  for (var u = 1; u < e.length; u++)
    if (i += _r(r, t, e[u]), n) {
      var I = a;
      i += I[u];
    }
  Ho.lastIndex = 0;
  for (var x = "", h; (h = Ho.exec(i)) !== null; )
    x += "-" + h[1];
  var f = Ua(i) + x;
  return {
    name: f,
    styles: i,
    next: ut
  };
}
var Xa = function(t) {
  return t();
}, Ja = ft["useInsertionEffect"] ? ft["useInsertionEffect"] : !1, Za = Ja || Xa, Qa = !1, Li = /* @__PURE__ */ ft.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ $a({
    key: "css"
  }) : null
);
Li.Provider;
var el = function(t) {
  return /* @__PURE__ */ Qi(function(r, n) {
    var i = pi(Li);
    return t(r, i, n);
  });
}, Bi = /* @__PURE__ */ ft.createContext({}), tl = function() {
  return ft.useContext(Bi);
}, Zr = {}.hasOwnProperty, xo = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Oi = function(t, r) {
  var n = {};
  for (var i in r)
    Zr.call(r, i) && (n[i] = r[i]);
  return n[xo] = t, n;
}, nl = function(t) {
  var r = t.cache, n = t.serialized, i = t.isStringTag;
  return _i(r, n, i), Za(function() {
    return Ga(r, n, i);
  }), null;
}, rl = /* @__PURE__ */ el(
  /* <any, any> */
  function(e, t, r) {
    var n = e.css;
    typeof n == "string" && t.registered[n] !== void 0 && (n = t.registered[n]);
    var i = e[xo], a = [n], d = "";
    typeof e.className == "string" ? d = Na(t.registered, a, e.className) : e.className != null && (d = e.className + " ");
    var u = Ei(a, void 0, ft.useContext(Bi));
    d += t.key + "-" + u.name;
    var I = {};
    for (var x in e)
      Zr.call(e, x) && x !== "css" && x !== xo && !Qa && (I[x] = e[x]);
    return I.className = d, r && (I.ref = r), /* @__PURE__ */ ft.createElement(ft.Fragment, null, /* @__PURE__ */ ft.createElement(nl, {
      cache: t,
      serialized: u,
      isStringTag: typeof i == "string"
    }), /* @__PURE__ */ ft.createElement(i, I));
  }
), Pi = rl, vo = vr.Fragment;
function N(e, t, r) {
  return Zr.call(t, "css") ? vr.jsx(Pi, Oi(e, t), r) : vr.jsx(e, t, r);
}
function Vt(e, t, r) {
  return Zr.call(t, "css") ? vr.jsxs(Pi, Oi(e, t), r) : vr.jsxs(e, t, r);
}
class ol extends ea {
  constructor() {
    super(...arguments);
    Lo(this, "state", {
      hasError: !1
    });
  }
  static getDerivedStateFromError(r) {
    return { hasError: !0, error: r };
  }
  componentDidCatch(r, n) {
    this.setState({ error: r, errorInfo: n });
  }
  render() {
    const { hasError: r, errorInfo: n, error: i } = this.state;
    return r ? /* @__PURE__ */ Vt(vo, { children: [
      /* @__PURE__ */ N("h1", { children: i == null ? void 0 : i.message }),
      /* @__PURE__ */ Vt("details", { children: [
        i == null ? void 0 : i.stack,
        n == null ? void 0 : n.componentStack
      ] })
    ] }) : this.props.children;
  }
}
const ue = (e, t) => e.startRowIdx === t.startRowIdx && e.endRowIdx === t.endRowIdx && e.startColIdx === t.startColIdx && e.endColIdx === t.endColIdx, z = {
  startRowIdx: -1,
  endRowIdx: -1,
  startColIdx: -1,
  endColIdx: -1
}, il = {
  rowIndex: -1,
  colIndex: -1
};
function $i(e, t) {
  const { start: r, end: n } = t;
  let i;
  const a = e.getColumnAmount(), d = e.getColumnAmount(), u = n.columnIndex >= a ? a - 1 : n.columnIndex, I = n.rowIndex >= d ? d - 1 : n.rowIndex;
  if (i = e.getCellByIndexes(I, u), e.getCellByIndexes(r.rowIndex, r.columnIndex)) {
    if (!i)
      throw new Error("Could not find a endCell with provided indexes");
  } else
    throw new Error("Could not find a startCell with provided indexes");
  const h = {
    startRowIdx: r.rowIndex,
    startColIdx: r.columnIndex,
    endRowIdx: n.rowIndex,
    endColIdx: n.columnIndex
  };
  return ue(h, z), h;
}
function al(e) {
  return e.map((r) => {
    const n = [], { range: i, styles: a } = r;
    for (let u = i.startRowIdx; u < i.endRowIdx; u++)
      for (let I = i.startColIdx; I < i.endColIdx; I++)
        n.push(`.rgRowIdx-${u}.rgColIdx-${I}`);
    return { [`${n.join(", ")}`]: a };
  });
}
function Di() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return Ei(t);
}
function ll(e, t) {
  const r = t.map((d) => {
    const { styles: u, range: I } = d;
    return { range: $i(e, I), styles: u };
  }), i = al(r).reduce((d, u) => ({ ...d, ...u }), {}), a = Object.entries(i).map(([d, u]) => {
    const I = Object.entries(u).map(([x, h]) => `${x}: ${h};`).join(" ");
    return `${d} { ${I} }`;
  }).join(" ");
  return Di`
    ${a}
  `;
}
const zo = (e) => {
  let t;
  const r = /* @__PURE__ */ new Set(), n = (h, f) => {
    const C = typeof h == "function" ? h(t) : h;
    if (!Object.is(C, t)) {
      const m = t;
      t = f ?? (typeof C != "object" || C === null) ? C : Object.assign({}, t, C), r.forEach((S) => S(t, m));
    }
  }, i = () => t, I = { setState: n, getState: i, getInitialState: () => x, subscribe: (h) => (r.add(h), () => r.delete(h)), destroy: () => {
    r.clear();
  } }, x = t = e(n, i, I);
  return I;
}, Mi = (e) => e ? zo(e) : zo;
var Io = { exports: {} }, to = {}, $r = { exports: {} }, no = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jo;
function dl() {
  if (jo)
    return no;
  jo = 1;
  var e = Yt;
  function t(f, C) {
    return f === C && (f !== 0 || 1 / f === 1 / C) || f !== f && C !== C;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, i = e.useEffect, a = e.useLayoutEffect, d = e.useDebugValue;
  function u(f, C) {
    var m = C(), S = n({ inst: { value: m, getSnapshot: C } }), p = S[0].inst, R = S[1];
    return a(function() {
      p.value = m, p.getSnapshot = C, I(p) && R({ inst: p });
    }, [f, m, C]), i(function() {
      return I(p) && R({ inst: p }), f(function() {
        I(p) && R({ inst: p });
      });
    }, [f]), d(m), m;
  }
  function I(f) {
    var C = f.getSnapshot;
    f = f.value;
    try {
      var m = C();
      return !r(f, m);
    } catch {
      return !0;
    }
  }
  function x(f, C) {
    return C();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? x : u;
  return no.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : h, no;
}
var ro = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var No;
function sl() {
  return No || (No = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Yt, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(_) {
      {
        for (var A = arguments.length, w = new Array(A > 1 ? A - 1 : 0), E = 1; E < A; E++)
          w[E - 1] = arguments[E];
        n("error", _, w);
      }
    }
    function n(_, A, w) {
      {
        var E = t.ReactDebugCurrentFrame, L = E.getStackAddendum();
        L !== "" && (A += "%s", w = w.concat([L]));
        var j = w.map(function(F) {
          return String(F);
        });
        j.unshift("Warning: " + A), Function.prototype.apply.call(console[_], console, j);
      }
    }
    function i(_, A) {
      return _ === A && (_ !== 0 || 1 / _ === 1 / A) || _ !== _ && A !== A;
    }
    var a = typeof Object.is == "function" ? Object.is : i, d = e.useState, u = e.useEffect, I = e.useLayoutEffect, x = e.useDebugValue, h = !1, f = !1;
    function C(_, A, w) {
      h || e.startTransition !== void 0 && (h = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var E = A();
      if (!f) {
        var L = A();
        a(E, L) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var j = d({
        inst: {
          value: E,
          getSnapshot: A
        }
      }), F = j[0].inst, W = j[1];
      return I(function() {
        F.value = E, F.getSnapshot = A, m(F) && W({
          inst: F
        });
      }, [_, E, A]), u(function() {
        m(F) && W({
          inst: F
        });
        var Y = function() {
          m(F) && W({
            inst: F
          });
        };
        return _(Y);
      }, [_]), x(E), E;
    }
    function m(_) {
      var A = _.getSnapshot, w = _.value;
      try {
        var E = A();
        return !a(w, E);
      } catch {
        return !0;
      }
    }
    function S(_, A, w) {
      return A();
    }
    var p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", R = !p, v = R ? S : C, y = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    ro.useSyncExternalStore = y, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ro;
}
var Go;
function Fi() {
  return Go || (Go = 1, process.env.NODE_ENV === "production" ? $r.exports = dl() : $r.exports = sl()), $r.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uo;
function cl() {
  if (Uo)
    return to;
  Uo = 1;
  var e = Yt, t = Fi();
  function r(x, h) {
    return x === h && (x !== 0 || 1 / x === 1 / h) || x !== x && h !== h;
  }
  var n = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, a = e.useRef, d = e.useEffect, u = e.useMemo, I = e.useDebugValue;
  return to.useSyncExternalStoreWithSelector = function(x, h, f, C, m) {
    var S = a(null);
    if (S.current === null) {
      var p = { hasValue: !1, value: null };
      S.current = p;
    } else
      p = S.current;
    S = u(function() {
      function v(E) {
        if (!y) {
          if (y = !0, _ = E, E = C(E), m !== void 0 && p.hasValue) {
            var L = p.value;
            if (m(L, E))
              return A = L;
          }
          return A = E;
        }
        if (L = A, n(_, E))
          return L;
        var j = C(E);
        return m !== void 0 && m(L, j) ? L : (_ = E, A = j);
      }
      var y = !1, _, A, w = f === void 0 ? null : f;
      return [function() {
        return v(h());
      }, w === null ? void 0 : function() {
        return v(w());
      }];
    }, [h, f, C, m]);
    var R = i(x, S[0], S[1]);
    return d(function() {
      p.hasValue = !0, p.value = R;
    }, [R]), I(R), R;
  }, to;
}
var oo = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wo;
function ul() {
  return Wo || (Wo = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Yt, t = Fi();
    function r(h, f) {
      return h === f && (h !== 0 || 1 / h === 1 / f) || h !== h && f !== f;
    }
    var n = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, a = e.useRef, d = e.useEffect, u = e.useMemo, I = e.useDebugValue;
    function x(h, f, C, m, S) {
      var p = a(null), R;
      p.current === null ? (R = {
        hasValue: !1,
        value: null
      }, p.current = R) : R = p.current;
      var v = u(function() {
        var w = !1, E, L, j = function(T) {
          if (!w) {
            w = !0, E = T;
            var B = m(T);
            if (S !== void 0 && R.hasValue) {
              var H = R.value;
              if (S(H, B))
                return L = H, H;
            }
            return L = B, B;
          }
          var M = E, V = L;
          if (n(M, T))
            return V;
          var Q = m(T);
          return S !== void 0 && S(V, Q) ? V : (E = T, L = Q, Q);
        }, F = C === void 0 ? null : C, W = function() {
          return j(f());
        }, Y = F === null ? void 0 : function() {
          return j(F());
        };
        return [W, Y];
      }, [f, C, m, S]), y = v[0], _ = v[1], A = i(h, y, _);
      return d(function() {
        R.hasValue = !0, R.value = A;
      }, [A]), I(A), A;
    }
    oo.useSyncExternalStoreWithSelector = x, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), oo;
}
process.env.NODE_ENV === "production" ? Io.exports = cl() : Io.exports = ul();
var fl = Io.exports;
const xl = /* @__PURE__ */ Jr(fl), { useDebugValue: Il } = Yt, { useSyncExternalStoreWithSelector: hl } = xl;
const pl = (e) => e;
function bo(e, t = pl, r) {
  const n = hl(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    r
  );
  return Il(n), n;
}
const ko = (e) => {
  const t = typeof e == "function" ? Mi(e) : e, r = (n, i) => bo(t, n, i);
  return Object.assign(r, t), r;
}, gl = (e) => e ? ko(e) : ko;
var kr = { exports: {} };
kr.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, a = 2, d = 9007199254740991, u = "[object Arguments]", I = "[object Array]", x = "[object AsyncFunction]", h = "[object Boolean]", f = "[object Date]", C = "[object Error]", m = "[object Function]", S = "[object GeneratorFunction]", p = "[object Map]", R = "[object Number]", v = "[object Null]", y = "[object Object]", _ = "[object Promise]", A = "[object Proxy]", w = "[object RegExp]", E = "[object Set]", L = "[object String]", j = "[object Symbol]", F = "[object Undefined]", W = "[object WeakMap]", Y = "[object ArrayBuffer]", T = "[object DataView]", B = "[object Float32Array]", H = "[object Float64Array]", M = "[object Int8Array]", V = "[object Int16Array]", Q = "[object Int32Array]", be = "[object Uint8Array]", Xe = "[object Uint8ClampedArray]", q = "[object Uint16Array]", Jt = "[object Uint32Array]", Zt = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, ht = /^(?:0|[1-9]\d*)$/, Z = {};
  Z[B] = Z[H] = Z[M] = Z[V] = Z[Q] = Z[be] = Z[Xe] = Z[q] = Z[Jt] = !0, Z[u] = Z[I] = Z[Y] = Z[h] = Z[T] = Z[f] = Z[C] = Z[m] = Z[p] = Z[R] = Z[y] = Z[w] = Z[E] = Z[L] = Z[W] = !1;
  var He = typeof Ye == "object" && Ye && Ye.Object === Object && Ye, Lt = typeof self == "object" && self && self.Object === Object && self, pe = He || Lt || Function("return this")(), pt = t && !t.nodeType && t, ot = pt && !0 && e && !e.nodeType && e, it = ot && ot.exports === pt, $ = it && He.process, at = function() {
    try {
      return $ && $.binding && $.binding("util");
    } catch {
    }
  }(), ze = at && at.isTypedArray;
  function gt(o, s) {
    for (var l = -1, c = o == null ? 0 : o.length, g = 0, b = []; ++l < c; ) {
      var O = o[l];
      s(O, l, o) && (b[g++] = O);
    }
    return b;
  }
  function Qt(o, s) {
    for (var l = -1, c = s.length, g = o.length; ++l < c; )
      o[g + l] = s[l];
    return o;
  }
  function Sn(o, s) {
    for (var l = -1, c = o == null ? 0 : o.length; ++l < c; )
      if (s(o[l], l, o))
        return !0;
    return !1;
  }
  function kn(o, s) {
    for (var l = -1, c = Array(o); ++l < o; )
      c[l] = s(l);
    return c;
  }
  function Kn(o) {
    return function(s) {
      return o(s);
    };
  }
  function Je(o, s) {
    return o.has(s);
  }
  function wt(o, s) {
    return o == null ? void 0 : o[s];
  }
  function Ct(o) {
    var s = -1, l = Array(o.size);
    return o.forEach(function(c, g) {
      l[++s] = [g, c];
    }), l;
  }
  function Ee(o, s) {
    return function(l) {
      return o(s(l));
    };
  }
  function Pe(o) {
    var s = -1, l = Array(o.size);
    return o.forEach(function(c) {
      l[++s] = c;
    }), l;
  }
  var Rt = Array.prototype, Vn = Function.prototype, mt = Object.prototype, Ze = pe["__core-js_shared__"], Bt = Vn.toString, Ae = mt.hasOwnProperty, en = function() {
    var o = /[^.]+$/.exec(Ze && Ze.keys && Ze.keys.IE_PROTO || "");
    return o ? "Symbol(src)_1." + o : "";
  }(), tn = mt.toString, yn = RegExp(
    "^" + Bt.call(Ae).replace(Zt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), nn = it ? pe.Buffer : void 0, Ot = pe.Symbol, je = pe.Uint8Array, Qe = mt.propertyIsEnumerable, St = Rt.splice, Le = Ot ? Ot.toStringTag : void 0, Pt = Object.getOwnPropertySymbols, $t = nn ? nn.isBuffer : void 0, $e = Ee(Object.keys, Object), rn = Ge(pe, "DataView"), _e = Ge(pe, "Map"), on = Ge(pe, "Promise"), an = Ge(pe, "Set"), ln = Ge(pe, "WeakMap"), lt = Ge(Object, "create"), vn = we(rn), ge = we(_e), Yn = we(on), qn = we(an), Xn = we(ln), bn = Ot ? Ot.prototype : void 0, dn = bn ? bn.valueOf : void 0;
  function ae(o) {
    var s = -1, l = o == null ? 0 : o.length;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function Jn() {
    this.__data__ = lt ? lt(null) : {}, this.size = 0;
  }
  function Zn(o) {
    var s = this.has(o) && delete this.__data__[o];
    return this.size -= s ? 1 : 0, s;
  }
  function Qn(o) {
    var s = this.__data__;
    if (lt) {
      var l = s[o];
      return l === n ? void 0 : l;
    }
    return Ae.call(s, o) ? s[o] : void 0;
  }
  function er(o) {
    var s = this.__data__;
    return lt ? s[o] !== void 0 : Ae.call(s, o);
  }
  function tr(o, s) {
    var l = this.__data__;
    return this.size += this.has(o) ? 0 : 1, l[o] = lt && s === void 0 ? n : s, this;
  }
  ae.prototype.clear = Jn, ae.prototype.delete = Zn, ae.prototype.get = Qn, ae.prototype.has = er, ae.prototype.set = tr;
  function se(o) {
    var s = -1, l = o == null ? 0 : o.length;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function nr() {
    this.__data__ = [], this.size = 0;
  }
  function rr(o) {
    var s = this.__data__, l = Ft(s, o);
    if (l < 0)
      return !1;
    var c = s.length - 1;
    return l == c ? s.pop() : St.call(s, l, 1), --this.size, !0;
  }
  function or(o) {
    var s = this.__data__, l = Ft(s, o);
    return l < 0 ? void 0 : s[l][1];
  }
  function ir(o) {
    return Ft(this.__data__, o) > -1;
  }
  function ar(o, s) {
    var l = this.__data__, c = Ft(l, o);
    return c < 0 ? (++this.size, l.push([o, s])) : l[c][1] = s, this;
  }
  se.prototype.clear = nr, se.prototype.delete = rr, se.prototype.get = or, se.prototype.has = ir, se.prototype.set = ar;
  function ye(o) {
    var s = -1, l = o == null ? 0 : o.length;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function sn() {
    this.size = 0, this.__data__ = {
      hash: new ae(),
      map: new (_e || se)(),
      string: new ae()
    };
  }
  function lr(o) {
    var s = De(this, o).delete(o);
    return this.size -= s ? 1 : 0, s;
  }
  function Dt(o) {
    return De(this, o).get(o);
  }
  function cn(o) {
    return De(this, o).has(o);
  }
  function dr(o, s) {
    var l = De(this, o), c = l.size;
    return l.set(o, s), this.size += l.size == c ? 0 : 1, this;
  }
  ye.prototype.clear = sn, ye.prototype.delete = lr, ye.prototype.get = Dt, ye.prototype.has = cn, ye.prototype.set = dr;
  function et(o) {
    var s = -1, l = o == null ? 0 : o.length;
    for (this.__data__ = new ye(); ++s < l; )
      this.add(o[s]);
  }
  function un(o) {
    return this.__data__.set(o, n), this;
  }
  function Mt(o) {
    return this.__data__.has(o);
  }
  et.prototype.add = et.prototype.push = un, et.prototype.has = Mt;
  function Ne(o) {
    var s = this.__data__ = new se(o);
    this.size = s.size;
  }
  function fn() {
    this.__data__ = new se(), this.size = 0;
  }
  function An(o) {
    var s = this.__data__, l = s.delete(o);
    return this.size = s.size, l;
  }
  function sr(o) {
    return this.__data__.get(o);
  }
  function cr(o) {
    return this.__data__.has(o);
  }
  function ur(o, s) {
    var l = this.__data__;
    if (l instanceof se) {
      var c = l.__data__;
      if (!_e || c.length < r - 1)
        return c.push([o, s]), this.size = ++l.size, this;
      l = this.__data__ = new ye(c);
    }
    return l.set(o, s), this.size = l.size, this;
  }
  Ne.prototype.clear = fn, Ne.prototype.delete = An, Ne.prototype.get = sr, Ne.prototype.has = cr, Ne.prototype.set = ur;
  function fr(o, s) {
    var l = Nt(o), c = !l && jt(o), g = !l && !c && dt(o), b = !l && !c && !g && On(o), O = l || c || g || b, D = O ? kn(o.length, String) : [], G = D.length;
    for (var P in o)
      (s || Ae.call(o, P)) && !(O && // Safari 9 has enumerable `arguments.length` in strict mode.
      (P == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      g && (P == "offset" || P == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      b && (P == "buffer" || P == "byteLength" || P == "byteOffset") || // Skip index properties.
      pn(P, G))) && D.push(P);
    return D;
  }
  function Ft(o, s) {
    for (var l = o.length; l--; )
      if (zt(o[l][0], s))
        return l;
    return -1;
  }
  function xn(o, s, l) {
    var c = s(o);
    return Nt(o) ? c : Qt(c, l(o));
  }
  function yt(o) {
    return o == null ? o === void 0 ? F : v : Le && Le in Object(o) ? tt(o) : bt(o);
  }
  function _n(o) {
    return Me(o) && yt(o) == u;
  }
  function Tn(o, s, l, c, g) {
    return o === s ? !0 : o == null || s == null || !Me(o) && !Me(s) ? o !== o && s !== s : xr(o, s, l, c, Tn, g);
  }
  function xr(o, s, l, c, g, b) {
    var O = Nt(o), D = Nt(s), G = O ? I : Ue(o), P = D ? I : Ue(s);
    G = G == u ? y : G, P = P == u ? y : P;
    var k = G == y, ie = P == y, X = G == P;
    if (X && dt(o)) {
      if (!dt(s))
        return !1;
      O = !0, k = !1;
    }
    if (X && !k)
      return b || (b = new Ne()), O || On(o) ? hn(o, s, l, c, g, b) : En(o, s, G, l, c, g, b);
    if (!(l & i)) {
      var ce = k && Ae.call(o, "__wrapped__"), fe = ie && Ae.call(s, "__wrapped__");
      if (ce || fe) {
        var ke = ce ? o.value() : o, Ke = fe ? s.value() : s;
        return b || (b = new Ne()), g(ke, Ke, l, c, b);
      }
    }
    return X ? (b || (b = new Ne()), hr(o, s, l, c, g, b)) : !1;
  }
  function Ht(o) {
    if (!Bn(o) || wr(o))
      return !1;
    var s = We(o) ? yn : K;
    return s.test(we(o));
  }
  function In(o) {
    return Me(o) && nt(o.length) && !!Z[yt(o)];
  }
  function Ir(o) {
    if (!Cr(o))
      return $e(o);
    var s = [];
    for (var l in Object(o))
      Ae.call(o, l) && l != "constructor" && s.push(l);
    return s;
  }
  function hn(o, s, l, c, g, b) {
    var O = l & i, D = o.length, G = s.length;
    if (D != G && !(O && G > D))
      return !1;
    var P = b.get(o);
    if (P && b.get(s))
      return P == s;
    var k = -1, ie = !0, X = l & a ? new et() : void 0;
    for (b.set(o, s), b.set(s, o); ++k < D; ) {
      var ce = o[k], fe = s[k];
      if (c)
        var ke = O ? c(fe, ce, k, s, o, b) : c(ce, fe, k, o, s, b);
      if (ke !== void 0) {
        if (ke)
          continue;
        ie = !1;
        break;
      }
      if (X) {
        if (!Sn(s, function(Ke, gn) {
          if (!Je(X, gn) && (ce === Ke || g(ce, Ke, l, c, b)))
            return X.push(gn);
        })) {
          ie = !1;
          break;
        }
      } else if (!(ce === fe || g(ce, fe, l, c, b))) {
        ie = !1;
        break;
      }
    }
    return b.delete(o), b.delete(s), ie;
  }
  function En(o, s, l, c, g, b, O) {
    switch (l) {
      case T:
        if (o.byteLength != s.byteLength || o.byteOffset != s.byteOffset)
          return !1;
        o = o.buffer, s = s.buffer;
      case Y:
        return !(o.byteLength != s.byteLength || !b(new je(o), new je(s)));
      case h:
      case f:
      case R:
        return zt(+o, +s);
      case C:
        return o.name == s.name && o.message == s.message;
      case w:
      case L:
        return o == s + "";
      case p:
        var D = Ct;
      case E:
        var G = c & i;
        if (D || (D = Pe), o.size != s.size && !G)
          return !1;
        var P = O.get(o);
        if (P)
          return P == s;
        c |= a, O.set(o, s);
        var k = hn(D(o), D(s), c, g, b, O);
        return O.delete(o), k;
      case j:
        if (dn)
          return dn.call(o) == dn.call(s);
    }
    return !1;
  }
  function hr(o, s, l, c, g, b) {
    var O = l & i, D = vt(o), G = D.length, P = vt(s), k = P.length;
    if (G != k && !O)
      return !1;
    for (var ie = G; ie--; ) {
      var X = D[ie];
      if (!(O ? X in s : Ae.call(s, X)))
        return !1;
    }
    var ce = b.get(o);
    if (ce && b.get(s))
      return ce == s;
    var fe = !0;
    b.set(o, s), b.set(s, o);
    for (var ke = O; ++ie < G; ) {
      X = D[ie];
      var Ke = o[X], gn = s[X];
      if (c)
        var Eo = O ? c(gn, Ke, X, s, o, b) : c(Ke, gn, X, o, s, b);
      if (!(Eo === void 0 ? Ke === gn || g(Ke, gn, l, c, b) : Eo)) {
        fe = !1;
        break;
      }
      ke || (ke = X == "constructor");
    }
    if (fe && !ke) {
      var Br = o.constructor, Or = s.constructor;
      Br != Or && "constructor" in o && "constructor" in s && !(typeof Br == "function" && Br instanceof Br && typeof Or == "function" && Or instanceof Or) && (fe = !1);
    }
    return b.delete(o), b.delete(s), fe;
  }
  function vt(o) {
    return xn(o, Ut, pr);
  }
  function De(o, s) {
    var l = o.__data__;
    return gr(s) ? l[typeof s == "string" ? "string" : "hash"] : l.map;
  }
  function Ge(o, s) {
    var l = wt(o, s);
    return Ht(l) ? l : void 0;
  }
  function tt(o) {
    var s = Ae.call(o, Le), l = o[Le];
    try {
      o[Le] = void 0;
      var c = !0;
    } catch {
    }
    var g = tn.call(o);
    return c && (s ? o[Le] = l : delete o[Le]), g;
  }
  var pr = Pt ? function(o) {
    return o == null ? [] : (o = Object(o), gt(Pt(o), function(s) {
      return Qe.call(o, s);
    }));
  } : Rr, Ue = yt;
  (rn && Ue(new rn(new ArrayBuffer(1))) != T || _e && Ue(new _e()) != p || on && Ue(on.resolve()) != _ || an && Ue(new an()) != E || ln && Ue(new ln()) != W) && (Ue = function(o) {
    var s = yt(o), l = s == y ? o.constructor : void 0, c = l ? we(l) : "";
    if (c)
      switch (c) {
        case vn:
          return T;
        case ge:
          return p;
        case Yn:
          return _;
        case qn:
          return E;
        case Xn:
          return W;
      }
    return s;
  });
  function pn(o, s) {
    return s = s ?? d, !!s && (typeof o == "number" || ht.test(o)) && o > -1 && o % 1 == 0 && o < s;
  }
  function gr(o) {
    var s = typeof o;
    return s == "string" || s == "number" || s == "symbol" || s == "boolean" ? o !== "__proto__" : o === null;
  }
  function wr(o) {
    return !!en && en in o;
  }
  function Cr(o) {
    var s = o && o.constructor, l = typeof s == "function" && s.prototype || mt;
    return o === l;
  }
  function bt(o) {
    return tn.call(o);
  }
  function we(o) {
    if (o != null) {
      try {
        return Bt.call(o);
      } catch {
      }
      try {
        return o + "";
      } catch {
      }
    }
    return "";
  }
  function zt(o, s) {
    return o === s || o !== o && s !== s;
  }
  var jt = _n(function() {
    return arguments;
  }()) ? _n : function(o) {
    return Me(o) && Ae.call(o, "callee") && !Qe.call(o, "callee");
  }, Nt = Array.isArray;
  function Gt(o) {
    return o != null && nt(o.length) && !We(o);
  }
  var dt = $t || mr;
  function Ln(o, s) {
    return Tn(o, s);
  }
  function We(o) {
    if (!Bn(o))
      return !1;
    var s = yt(o);
    return s == m || s == S || s == x || s == A;
  }
  function nt(o) {
    return typeof o == "number" && o > -1 && o % 1 == 0 && o <= d;
  }
  function Bn(o) {
    var s = typeof o;
    return o != null && (s == "object" || s == "function");
  }
  function Me(o) {
    return o != null && typeof o == "object";
  }
  var On = ze ? Kn(ze) : In;
  function Ut(o) {
    return Gt(o) ? fr(o) : Ir(o);
  }
  function Rr() {
    return [];
  }
  function mr() {
    return !1;
  }
  e.exports = Ln;
})(kr, kr.exports);
var wl = kr.exports;
const Ce = /* @__PURE__ */ Jr(wl), Cl = (e) => "rowSpan" in e || "colSpan" in e, Be = (e) => e ? "originRowIndex" in e && "originColIndex" in e : !1, Lr = (e, t) => Be(t) ? e.getCellByIndexes(t.originRowIndex, t.originColIndex) : t, J = (e, t) => {
  if (!t)
    return z;
  const r = Lr(e, t);
  return Cl(r) ? {
    startRowIdx: r.rowIndex,
    endRowIdx: r.rowIndex + ((r == null ? void 0 : r.rowSpan) ?? 1),
    startColIdx: r.colIndex,
    endColIdx: r.colIndex + ((r == null ? void 0 : r.colSpan) ?? 1)
  } : {
    startRowIdx: r.rowIndex,
    endRowIdx: r.rowIndex + 1,
    startColIdx: r.colIndex,
    endColIdx: r.colIndex + 1
  };
}, me = (e, t) => {
  let r = !1;
  const n = { ...t };
  for (let i = t.startRowIdx; i < t.endRowIdx; i++)
    for (let a = t.startColIdx; a < t.endColIdx; a++) {
      const d = e.getCellByIndexes(i, a);
      if (!d)
        continue;
      const u = J(e, d);
      u.startRowIdx < n.startRowIdx && (n.startRowIdx = u.startRowIdx, r = !0), u.endRowIdx > n.endRowIdx && (n.endRowIdx = u.endRowIdx, r = !0), u.startColIdx < n.startColIdx && (n.startColIdx = u.startColIdx, r = !0), u.endColIdx > n.endColIdx && (n.endColIdx = u.endColIdx, r = !0);
    }
  return r ? me(e, n) : n;
};
function le(e, t) {
  var n;
  if (!e.reactGridRef)
    return;
  const r = (n = e.reactGridRef) == null ? void 0 : n.getElementsByClassName(
    `rgRowIdx-${t.rowIndex} rgColIdx-${t.colIndex}`
  );
  if (!(!r || (r == null ? void 0 : r.length) === 0)) {
    if ((r == null ? void 0 : r.length) !== 1)
      throw new Error("Cell container is not unique!");
    return r[0];
  }
}
const Et = (e, t) => {
  const r = document.elementsFromPoint(e, t);
  for (const n of r) {
    const i = n;
    if (i.classList.contains("rgCellContainer"))
      return i;
    if (i.closest(".rgCellContainer"))
      return i.closest(".rgCellContainer");
  }
  return null;
};
function Cn(e) {
  const t = /rgRowIdx-(\d+)/.exec(e.classList.value), r = /rgColIdx-(\d+)/.exec(e.classList.value);
  if (!t || !r)
    return { rowIndex: -1, colIndex: -1 };
  const n = parseInt(t[1]), i = parseInt(r[1]);
  return { rowIndex: n, colIndex: i };
}
const jn = (e, t) => {
  const r = { rowIndex: -1, colIndex: -1 }, n = Et(e, t);
  if (!n)
    return r;
  const i = Cn(n);
  if (!i)
    return r;
  const { rowIndex: a, colIndex: d } = i;
  return { rowIndex: a, colIndex: d };
}, Rl = "Center", ml = (e, t) => document.elementsFromPoint(e, t).filter((i) => i.classList.contains("rgCellContainer")).find(
  (i) => {
    var a;
    return (a = i.closest(".rgPane")) == null ? void 0 : a.classList.contains(`rgPane-${Rl}`);
  }
), $n = (e, t) => {
  if (!t)
    return null;
  const r = le(e, t);
  if (!r)
    return null;
  const n = Cn(r);
  for (const i in e.paneRanges) {
    const a = e.paneRanges[i];
    if (n.rowIndex >= a.startRowIdx && n.rowIndex < a.endRowIdx && n.colIndex >= a.startColIdx && n.colIndex < a.endColIdx)
      return i;
  }
  return null;
}, de = (e, t, r) => {
  if (!t || Ce(r, z))
    return !1;
  const n = J(e, t);
  return n.startRowIdx >= r.startRowIdx && n.endRowIdx <= r.endRowIdx && n.startColIdx >= r.startColIdx && n.endColIdx <= r.endColIdx;
};
function Sl(e, t) {
  return !de(e, t, e.paneRanges.Center);
}
function qt() {
  return process.env.NODE_ENV === "development";
}
function yl(e, t) {
  var n;
  const r = (n = e.reactGridRef) == null ? void 0 : n.getElementsByClassName(
    `rgCellContainer rgRowIdx-${t.rowIndex} rgColIdx-${t.colIndex}`
  );
  if (!r)
    throw new Error("No cellContainer found for this cell!");
  if (r.length !== 1)
    throw new Error("There should be no two cells occupying the same space (simultaneously occupying X and Y)!");
  return r[0].closest(".rgPane");
}
function vl(e) {
  var r;
  return (r = [...e.classList].find((n) => n.includes("rgPane-"))) == null ? void 0 : r.replace("rgPane-", "");
}
const Rn = (e, t) => {
  let r = getComputedStyle(e);
  const n = r.position === "absolute", i = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
  if (r.position === "fixed")
    return document.documentElement;
  for (let a = e; a = a.parentElement; )
    if (r = getComputedStyle(a), !(n && r.position === "static") && i.test(r.overflow + r.overflowY + r.overflowX))
      return a;
  return bl();
}, bl = () => window;
function Al(e, t, r, n) {
  return Math.sqrt(Math.pow(e + t, 2) + Math.pow(r + n, 2));
}
const _l = (e, t) => {
  let r = 0, n = 0;
  switch (e.toLowerCase()) {
    case "left":
      r = -1;
      break;
    case "right":
      r = 1;
      break;
    case "top":
      n = -1;
      break;
    case "bottom":
      n = 1;
      break;
    case "topcenter":
      n = -1;
      break;
    case "bottomcenter":
      n = 1;
      break;
    case "topleft":
      r = -1, n = -1;
      break;
    case "topright":
      r = 1, n = -1;
      break;
    case "bottomleft":
      r = -1, n = 1;
      break;
    case "bottomright":
      r = 1, n = 1;
      break;
  }
  return t && (r *= t, n *= t), { x: r, y: n };
};
function rt(e, t, r, n = !1, i = !1) {
  const a = yl(e, t), d = vl(a), u = Rn(e.reactGridRef, !0), { rowIndex: I, colIndex: x } = e.focusedLocation, h = 8, f = Al(I, x, r.rowIndex, r.colIndex);
  let { x: C, y: m } = _l(d, h > f ? h : f);
  n && (m = 0), i && (C = 0), u == null || u.scrollBy(C, m);
}
qt();
const io = (e, {
  currentDragOverCell: t,
  startingPointerIdx: r,
  currentPointerIdx: n,
  shouldSelectEntireColumn: i = !0,
  shouldEnableRowSelection: a = !0
}) => {
  if (t.isSelectable === !1)
    return e;
  const d = structuredClone(e.selectedArea), u = structuredClone(e.focusedLocation);
  if (i) {
    d.startRowIdx = 0, d.endRowIdx = e.rows.length, n.colIndex < r.colIndex ? (d.startColIdx = n.colIndex, d.endColIdx = r.colIndex + 1) : (d.startColIdx = r.colIndex, d.endColIdx = n.colIndex + ((t == null ? void 0 : t.colSpan) || 1));
    for (let h = d.startColIdx; h < d.endColIdx; h++) {
      const f = e.cells.get(`0 ${h}`);
      if (!f)
        return e;
      if (Be(f)) {
        const C = e.getCellByIndexes(f.originRowIndex, f.originColIndex);
        if (C && (C.isSelectable === !1 || C.isFocusable === !1))
          return e;
      } else if (f.isSelectable === !1 || f.isFocusable === !1)
        return e;
    }
  } else if (a) {
    d.startColIdx = 0, d.endColIdx = e.columns.length, n.rowIndex < r.rowIndex ? (d.startRowIdx = n.rowIndex, d.endRowIdx = r.rowIndex + 1) : (d.startRowIdx = r.rowIndex, d.endRowIdx = n.rowIndex + ((t == null ? void 0 : t.rowSpan) || 1));
    for (let h = d.startRowIdx; h < d.endRowIdx; h++) {
      const f = e.cells.get(`${h} 0`);
      if (!f)
        return e;
      if (Be(f)) {
        const C = e.getCellByIndexes(f.originRowIndex, f.originColIndex);
        if (C && (C.isSelectable === !1 || C.isFocusable === !1))
          return e;
      } else if (f.isSelectable === !1 || f.isFocusable === !1)
        return e;
    }
  } else
    n.rowIndex < u.rowIndex ? (d.endRowIdx = u.rowIndex + 1, d.startRowIdx = n.rowIndex) : (d.endRowIdx = n.rowIndex + ((t == null ? void 0 : t.rowSpan) || 1), d.startRowIdx = u.rowIndex), n.colIndex < u.colIndex ? (d.endColIdx = u.colIndex + 1, d.startColIdx = n.colIndex) : (d.endColIdx = n.colIndex + ((t == null ? void 0 : t.colSpan) || 1), d.startColIdx = u.colIndex);
  const I = me(e, d), x = J(e, t);
  return Ce(I, x) ? {
    ...e,
    selectedArea: z
  } : {
    ...e,
    selectedArea: I
  };
}, Hi = {
  id: "CellSelection",
  handlePointerMove(e, t) {
    const { clientX: r, clientY: n } = e, i = jn(r, n), a = t.getCellByIndexes(i.rowIndex, i.colIndex);
    let d;
    if (Ce(t.selectedArea, z) ? d = $n(t, t.getFocusedCell()) : d = $n(
      t,
      t.getCellByIndexes(t.pointerStartIdx.rowIndex, t.pointerStartIdx.colIndex)
    ), !a || (d === "Center" && rt(t, a, i), (d === "Left" || d === "Right") && rt(t, a, i, !1, !0), (d === "TopCenter" || d === "BottomCenter") && rt(t, a, i, !0), !Et(r, n)))
      return t;
    const I = t.pointerStartIdx.rowIndex === 0 && !!t.enableColumnSelectionOnFirstRow, x = t.pointerStartIdx.colIndex === 0 && !!t.enableRowSelectionOnFirstColumn;
    return io(t, {
      currentDragOverCell: a,
      startingPointerIdx: t.pointerStartIdx,
      currentPointerIdx: i,
      shouldSelectEntireColumn: I,
      shouldEnableRowSelection: x
    });
  },
  handlePointerUp(e, t) {
    var n;
    const r = t.getBehavior("Default");
    return (n = t.onAreaSelected) == null || n.call(t, t.selectedArea), {
      ...t,
      currentBehavior: r
    };
  },
  handlePointerDownTouch(e, t) {
    const r = t.getBehavior("Default");
    return {
      ...t,
      currentBehavior: r
    };
  },
  handlePointerUpTouch(e, t) {
    const r = t.getBehavior("Default");
    return {
      ...t,
      currentBehavior: r
    };
  },
  handlePointerEnter(e, t) {
    return t;
  },
  handlePointerHold: function(e, t) {
    return t;
  },
  handlePointerHoldTouch: function(e, t) {
    return t;
  },
  handlePointerMoveTouch(e, t) {
    const { clientX: r, clientY: n } = e, i = jn(r, n), a = t.getCellByIndexes(i.rowIndex, i.colIndex);
    let d;
    if (Ce(t.selectedArea, z) ? d = $n(t, t.getFocusedCell()) : d = $n(
      t,
      t.getCellByIndexes(t.pointerStartIdx.rowIndex, t.pointerStartIdx.colIndex)
    ), !a)
      return t;
    d === "Center" && rt(t, a, i), (d === "Left" || d === "Right") && rt(t, a, i, !1, !0), (d === "TopCenter" || d === "BottomCenter") && rt(t, a, i, !0);
    const u = Sl(t, a), I = u ? le(t, a) : ml(r, n);
    if (!I)
      return t;
    const x = t.pointerStartIdx.rowIndex === 0 && !!t.enableColumnSelectionOnFirstRow, h = t.pointerStartIdx.colIndex === 0 && !!t.enableRowSelectionOnFirstColumn;
    if (I && u) {
      const C = Cn(I) || il;
      return io(t, {
        currentDragOverCell: a,
        startingPointerIdx: t.pointerStartIdx,
        currentPointerIdx: C,
        shouldSelectEntireColumn: x,
        shouldEnableRowSelection: h
      });
    }
    return io(t, {
      currentDragOverCell: a,
      startingPointerIdx: t.pointerStartIdx,
      currentPointerIdx: i,
      shouldSelectEntireColumn: x,
      shouldEnableRowSelection: h
    });
  },
  handlePointerEnterTouch(e, t) {
    return t;
  }
};
function Dn(e) {
  const t = /rgRowIdx-(\d+)/, r = /rgColIdx-(\d+)/, n = t.exec(e.classList.value), i = r.exec(e.classList.value);
  return n && i ? {
    rowIndex: parseInt(n[1]),
    colIndex: parseInt(i[1])
  } : {
    rowIndex: -1,
    colIndex: -1
  };
}
function Wn(e, t = {}, r = { bubbles: !1, cancelable: !1, composed: !1 }) {
  let n = new Event(e, r);
  return t && (n = Object.assign(n, { reactgrid: t })), dispatchEvent(n);
}
const Tt = (e, t, r) => Be(t) ? de(
  e,
  e.cells.get(`${t.originRowIndex} ${t.originColIndex}`),
  e.paneRanges[r]
) : de(e, t, e.paneRanges[r]), ho = (e, t) => {
  const r = e.paneRanges;
  switch (t) {
    case "TopLeft":
      return r.TopLeft.endRowIdx > 0;
    case "TopCenter":
      return r.TopCenter.endRowIdx > 0;
    case "TopRight":
      return r.TopCenter.endRowIdx > 0;
    case "Left":
      return r.Left.endColIdx > 0;
    case "Right":
      return r.Right.startColIdx < e.columns.length;
    case "BottomLeft":
      return r.BottomLeft.startRowIdx < e.rows.length;
    case "BottomCenter":
      return r.BottomCenter.startRowIdx < e.rows.length;
    case "BottomRight":
      return r.BottomCenter.startRowIdx < e.rows.length;
    default:
      return !1;
  }
};
function zi(e, t) {
  if (!("rowIndex" in e) && !("rowIndex" in t)) {
    const n = Cn(e), i = Cn(t);
    return n && i && n.rowIndex === i.rowIndex && n.colIndex === i.colIndex;
  } else
    return "rowIndex" in e && "rowIndex" in t ? e.rowIndex === t.rowIndex && e.colIndex === t.colIndex : null;
}
const kt = (e, t, r) => {
  const n = e.getCellByIndexes(t.rowIndex, t.colIndex);
  if (!n || !ho(e, r))
    return 0;
  let i = null;
  switch (r) {
    case "Left":
      i = e.getCellByIndexes(t.rowIndex, e.paneRanges.Left.endColIdx - 1);
      break;
    case "Right":
      i = e.getCellByIndexes(t.rowIndex, e.paneRanges.Right.startColIdx);
      break;
    case "TopCenter":
      i = e.getCellByIndexes(e.paneRanges.TopCenter.endRowIdx - 1, t.colIndex);
      break;
    case "BottomCenter":
      i = e.getCellByIndexes(e.paneRanges.BottomCenter.startRowIdx, t.colIndex);
      break;
  }
  if (!i || Tt(e, n, r) || Tt(e, n, "TopRight") || Tt(e, n, "BottomRight") || Tt(e, n, "TopLeft") || Tt(e, n, "BottomLeft"))
    return 0;
  const a = le(e, i), d = le(e, n);
  if (!a || !d || zi(a, d))
    return 0;
  if (r === "Right") {
    const u = Math.abs(
      a.offsetLeft - (d.offsetLeft + d.offsetWidth)
    );
    return d.offsetLeft + d.offsetWidth <= a.offsetLeft ? 0 : u;
  }
  if (r === "Left") {
    const u = Math.abs(
      a.offsetLeft + a.offsetWidth - d.offsetLeft
    );
    return d.offsetLeft >= a.offsetLeft + a.offsetWidth ? 0 : u;
  }
  if (r === "BottomCenter") {
    const u = Math.abs(
      d.offsetTop + d.offsetHeight - a.offsetTop
    );
    return d.offsetTop + d.offsetHeight <= a.offsetTop ? 0 : u;
  }
  if (r === "TopCenter") {
    const u = Math.abs(
      a.offsetTop + a.offsetHeight - d.offsetTop
    );
    return d.offsetTop >= a.offsetTop + a.offsetHeight ? 0 : u;
  }
}, Nn = (e) => typeof e == "string" ? parseInt(e, 10) : e;
var Kr = { exports: {} };
Kr.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 800, a = 16, d = 9007199254740991, u = "[object Arguments]", I = "[object Array]", x = "[object AsyncFunction]", h = "[object Boolean]", f = "[object Date]", C = "[object Error]", m = "[object Function]", S = "[object GeneratorFunction]", p = "[object Map]", R = "[object Number]", v = "[object Null]", y = "[object Object]", _ = "[object Proxy]", A = "[object RegExp]", w = "[object Set]", E = "[object String]", L = "[object Undefined]", j = "[object WeakMap]", F = "[object ArrayBuffer]", W = "[object DataView]", Y = "[object Float32Array]", T = "[object Float64Array]", B = "[object Int8Array]", H = "[object Int16Array]", M = "[object Int32Array]", V = "[object Uint8Array]", Q = "[object Uint8ClampedArray]", be = "[object Uint16Array]", Xe = "[object Uint32Array]", q = /[\\^$.*+?()[\]{}|]/g, Jt = /^\[object .+?Constructor\]$/, Zt = /^(?:0|[1-9]\d*)$/, K = {};
  K[Y] = K[T] = K[B] = K[H] = K[M] = K[V] = K[Q] = K[be] = K[Xe] = !0, K[u] = K[I] = K[F] = K[h] = K[W] = K[f] = K[C] = K[m] = K[p] = K[R] = K[y] = K[A] = K[w] = K[E] = K[j] = !1;
  var ht = typeof Ye == "object" && Ye && Ye.Object === Object && Ye, Z = typeof self == "object" && self && self.Object === Object && self, He = ht || Z || Function("return this")(), Lt = t && !t.nodeType && t, pe = Lt && !0 && e && !e.nodeType && e, pt = pe && pe.exports === Lt, ot = pt && ht.process, it = function() {
    try {
      var l = pe && pe.require && pe.require("util").types;
      return l || ot && ot.binding && ot.binding("util");
    } catch {
    }
  }(), $ = it && it.isTypedArray;
  function at(l, c, g) {
    switch (g.length) {
      case 0:
        return l.call(c);
      case 1:
        return l.call(c, g[0]);
      case 2:
        return l.call(c, g[0], g[1]);
      case 3:
        return l.call(c, g[0], g[1], g[2]);
    }
    return l.apply(c, g);
  }
  function ze(l, c) {
    for (var g = -1, b = Array(l); ++g < l; )
      b[g] = c(g);
    return b;
  }
  function gt(l) {
    return function(c) {
      return l(c);
    };
  }
  function Qt(l, c) {
    return l == null ? void 0 : l[c];
  }
  function Sn(l, c) {
    return function(g) {
      return l(c(g));
    };
  }
  var kn = Array.prototype, Kn = Function.prototype, Je = Object.prototype, wt = He["__core-js_shared__"], Ct = Kn.toString, Ee = Je.hasOwnProperty, Pe = function() {
    var l = /[^.]+$/.exec(wt && wt.keys && wt.keys.IE_PROTO || "");
    return l ? "Symbol(src)_1." + l : "";
  }(), Rt = Je.toString, Vn = Ct.call(Object), mt = RegExp(
    "^" + Ct.call(Ee).replace(q, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ze = pt ? He.Buffer : void 0, Bt = He.Symbol, Ae = He.Uint8Array, en = Ze ? Ze.allocUnsafe : void 0, tn = Sn(Object.getPrototypeOf, Object), yn = Object.create, nn = Je.propertyIsEnumerable, Ot = kn.splice, je = Bt ? Bt.toStringTag : void 0, Qe = function() {
    try {
      var l = In(Object, "defineProperty");
      return l({}, "", {}), l;
    } catch {
    }
  }(), St = Ze ? Ze.isBuffer : void 0, Le = Math.max, Pt = Date.now, $t = In(He, "Map"), $e = In(Object, "create"), rn = function() {
    function l() {
    }
    return function(c) {
      if (!We(c))
        return {};
      if (yn)
        return yn(c);
      l.prototype = c;
      var g = new l();
      return l.prototype = void 0, g;
    };
  }();
  function _e(l) {
    var c = -1, g = l == null ? 0 : l.length;
    for (this.clear(); ++c < g; ) {
      var b = l[c];
      this.set(b[0], b[1]);
    }
  }
  function on() {
    this.__data__ = $e ? $e(null) : {}, this.size = 0;
  }
  function an(l) {
    var c = this.has(l) && delete this.__data__[l];
    return this.size -= c ? 1 : 0, c;
  }
  function ln(l) {
    var c = this.__data__;
    if ($e) {
      var g = c[l];
      return g === n ? void 0 : g;
    }
    return Ee.call(c, l) ? c[l] : void 0;
  }
  function lt(l) {
    var c = this.__data__;
    return $e ? c[l] !== void 0 : Ee.call(c, l);
  }
  function vn(l, c) {
    var g = this.__data__;
    return this.size += this.has(l) ? 0 : 1, g[l] = $e && c === void 0 ? n : c, this;
  }
  _e.prototype.clear = on, _e.prototype.delete = an, _e.prototype.get = ln, _e.prototype.has = lt, _e.prototype.set = vn;
  function ge(l) {
    var c = -1, g = l == null ? 0 : l.length;
    for (this.clear(); ++c < g; ) {
      var b = l[c];
      this.set(b[0], b[1]);
    }
  }
  function Yn() {
    this.__data__ = [], this.size = 0;
  }
  function qn(l) {
    var c = this.__data__, g = Dt(c, l);
    if (g < 0)
      return !1;
    var b = c.length - 1;
    return g == b ? c.pop() : Ot.call(c, g, 1), --this.size, !0;
  }
  function Xn(l) {
    var c = this.__data__, g = Dt(c, l);
    return g < 0 ? void 0 : c[g][1];
  }
  function bn(l) {
    return Dt(this.__data__, l) > -1;
  }
  function dn(l, c) {
    var g = this.__data__, b = Dt(g, l);
    return b < 0 ? (++this.size, g.push([l, c])) : g[b][1] = c, this;
  }
  ge.prototype.clear = Yn, ge.prototype.delete = qn, ge.prototype.get = Xn, ge.prototype.has = bn, ge.prototype.set = dn;
  function ae(l) {
    var c = -1, g = l == null ? 0 : l.length;
    for (this.clear(); ++c < g; ) {
      var b = l[c];
      this.set(b[0], b[1]);
    }
  }
  function Jn() {
    this.size = 0, this.__data__ = {
      hash: new _e(),
      map: new ($t || ge)(),
      string: new _e()
    };
  }
  function Zn(l) {
    var c = Ht(this, l).delete(l);
    return this.size -= c ? 1 : 0, c;
  }
  function Qn(l) {
    return Ht(this, l).get(l);
  }
  function er(l) {
    return Ht(this, l).has(l);
  }
  function tr(l, c) {
    var g = Ht(this, l), b = g.size;
    return g.set(l, c), this.size += g.size == b ? 0 : 1, this;
  }
  ae.prototype.clear = Jn, ae.prototype.delete = Zn, ae.prototype.get = Qn, ae.prototype.has = er, ae.prototype.set = tr;
  function se(l) {
    var c = this.__data__ = new ge(l);
    this.size = c.size;
  }
  function nr() {
    this.__data__ = new ge(), this.size = 0;
  }
  function rr(l) {
    var c = this.__data__, g = c.delete(l);
    return this.size = c.size, g;
  }
  function or(l) {
    return this.__data__.get(l);
  }
  function ir(l) {
    return this.__data__.has(l);
  }
  function ar(l, c) {
    var g = this.__data__;
    if (g instanceof ge) {
      var b = g.__data__;
      if (!$t || b.length < r - 1)
        return b.push([l, c]), this.size = ++g.size, this;
      g = this.__data__ = new ae(b);
    }
    return g.set(l, c), this.size = g.size, this;
  }
  se.prototype.clear = nr, se.prototype.delete = rr, se.prototype.get = or, se.prototype.has = ir, se.prototype.set = ar;
  function ye(l, c) {
    var g = zt(l), b = !g && we(l), O = !g && !b && Gt(l), D = !g && !b && !O && Me(l), G = g || b || O || D, P = G ? ze(l.length, String) : [], k = P.length;
    for (var ie in l)
      (c || Ee.call(l, ie)) && !(G && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ie == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      O && (ie == "offset" || ie == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      D && (ie == "buffer" || ie == "byteLength" || ie == "byteOffset") || // Skip index properties.
      En(ie, k))) && P.push(ie);
    return P;
  }
  function sn(l, c, g) {
    (g !== void 0 && !bt(l[c], g) || g === void 0 && !(c in l)) && cn(l, c, g);
  }
  function lr(l, c, g) {
    var b = l[c];
    (!(Ee.call(l, c) && bt(b, g)) || g === void 0 && !(c in l)) && cn(l, c, g);
  }
  function Dt(l, c) {
    for (var g = l.length; g--; )
      if (bt(l[g][0], c))
        return g;
    return -1;
  }
  function cn(l, c, g) {
    c == "__proto__" && Qe ? Qe(l, c, {
      configurable: !0,
      enumerable: !0,
      value: g,
      writable: !0
    }) : l[c] = g;
  }
  var dr = xr();
  function et(l) {
    return l == null ? l === void 0 ? L : v : je && je in Object(l) ? Ir(l) : pr(l);
  }
  function un(l) {
    return nt(l) && et(l) == u;
  }
  function Mt(l) {
    if (!We(l) || De(l))
      return !1;
    var c = dt(l) ? mt : Jt;
    return c.test(Cr(l));
  }
  function Ne(l) {
    return nt(l) && Ln(l.length) && !!K[et(l)];
  }
  function fn(l) {
    if (!We(l))
      return tt(l);
    var c = Ge(l), g = [];
    for (var b in l)
      b == "constructor" && (c || !Ee.call(l, b)) || g.push(b);
    return g;
  }
  function An(l, c, g, b, O) {
    l !== c && dr(c, function(D, G) {
      if (O || (O = new se()), We(D))
        sr(l, c, G, g, An, b, O);
      else {
        var P = b ? b(pn(l, G), D, G + "", l, c, O) : void 0;
        P === void 0 && (P = D), sn(l, G, P);
      }
    }, Ut);
  }
  function sr(l, c, g, b, O, D, G) {
    var P = pn(l, g), k = pn(c, g), ie = G.get(k);
    if (ie) {
      sn(l, g, ie);
      return;
    }
    var X = D ? D(P, k, g + "", l, c, G) : void 0, ce = X === void 0;
    if (ce) {
      var fe = zt(k), ke = !fe && Gt(k), Ke = !fe && !ke && Me(k);
      X = k, fe || ke || Ke ? zt(P) ? X = P : Nt(P) ? X = yt(P) : ke ? (ce = !1, X = fr(k, !0)) : Ke ? (ce = !1, X = xn(k, !0)) : X = [] : Bn(k) || we(k) ? (X = P, we(P) ? X = On(P) : (!We(P) || dt(P)) && (X = hn(k))) : ce = !1;
    }
    ce && (G.set(k, X), O(X, k, b, D, G), G.delete(k)), sn(l, g, X);
  }
  function cr(l, c) {
    return gr(Ue(l, c, o), l + "");
  }
  var ur = Qe ? function(l, c) {
    return Qe(l, "toString", {
      configurable: !0,
      enumerable: !1,
      value: mr(c),
      writable: !0
    });
  } : o;
  function fr(l, c) {
    if (c)
      return l.slice();
    var g = l.length, b = en ? en(g) : new l.constructor(g);
    return l.copy(b), b;
  }
  function Ft(l) {
    var c = new l.constructor(l.byteLength);
    return new Ae(c).set(new Ae(l)), c;
  }
  function xn(l, c) {
    var g = c ? Ft(l.buffer) : l.buffer;
    return new l.constructor(g, l.byteOffset, l.length);
  }
  function yt(l, c) {
    var g = -1, b = l.length;
    for (c || (c = Array(b)); ++g < b; )
      c[g] = l[g];
    return c;
  }
  function _n(l, c, g, b) {
    var O = !g;
    g || (g = {});
    for (var D = -1, G = c.length; ++D < G; ) {
      var P = c[D], k = b ? b(g[P], l[P], P, g, l) : void 0;
      k === void 0 && (k = l[P]), O ? cn(g, P, k) : lr(g, P, k);
    }
    return g;
  }
  function Tn(l) {
    return cr(function(c, g) {
      var b = -1, O = g.length, D = O > 1 ? g[O - 1] : void 0, G = O > 2 ? g[2] : void 0;
      for (D = l.length > 3 && typeof D == "function" ? (O--, D) : void 0, G && hr(g[0], g[1], G) && (D = O < 3 ? void 0 : D, O = 1), c = Object(c); ++b < O; ) {
        var P = g[b];
        P && l(c, P, b, D);
      }
      return c;
    });
  }
  function xr(l) {
    return function(c, g, b) {
      for (var O = -1, D = Object(c), G = b(c), P = G.length; P--; ) {
        var k = G[l ? P : ++O];
        if (g(D[k], k, D) === !1)
          break;
      }
      return c;
    };
  }
  function Ht(l, c) {
    var g = l.__data__;
    return vt(c) ? g[typeof c == "string" ? "string" : "hash"] : g.map;
  }
  function In(l, c) {
    var g = Qt(l, c);
    return Mt(g) ? g : void 0;
  }
  function Ir(l) {
    var c = Ee.call(l, je), g = l[je];
    try {
      l[je] = void 0;
      var b = !0;
    } catch {
    }
    var O = Rt.call(l);
    return b && (c ? l[je] = g : delete l[je]), O;
  }
  function hn(l) {
    return typeof l.constructor == "function" && !Ge(l) ? rn(tn(l)) : {};
  }
  function En(l, c) {
    var g = typeof l;
    return c = c ?? d, !!c && (g == "number" || g != "symbol" && Zt.test(l)) && l > -1 && l % 1 == 0 && l < c;
  }
  function hr(l, c, g) {
    if (!We(g))
      return !1;
    var b = typeof c;
    return (b == "number" ? jt(g) && En(c, g.length) : b == "string" && c in g) ? bt(g[c], l) : !1;
  }
  function vt(l) {
    var c = typeof l;
    return c == "string" || c == "number" || c == "symbol" || c == "boolean" ? l !== "__proto__" : l === null;
  }
  function De(l) {
    return !!Pe && Pe in l;
  }
  function Ge(l) {
    var c = l && l.constructor, g = typeof c == "function" && c.prototype || Je;
    return l === g;
  }
  function tt(l) {
    var c = [];
    if (l != null)
      for (var g in Object(l))
        c.push(g);
    return c;
  }
  function pr(l) {
    return Rt.call(l);
  }
  function Ue(l, c, g) {
    return c = Le(c === void 0 ? l.length - 1 : c, 0), function() {
      for (var b = arguments, O = -1, D = Le(b.length - c, 0), G = Array(D); ++O < D; )
        G[O] = b[c + O];
      O = -1;
      for (var P = Array(c + 1); ++O < c; )
        P[O] = b[O];
      return P[c] = g(G), at(l, this, P);
    };
  }
  function pn(l, c) {
    if (!(c === "constructor" && typeof l[c] == "function") && c != "__proto__")
      return l[c];
  }
  var gr = wr(ur);
  function wr(l) {
    var c = 0, g = 0;
    return function() {
      var b = Pt(), O = a - (b - g);
      if (g = b, O > 0) {
        if (++c >= i)
          return arguments[0];
      } else
        c = 0;
      return l.apply(void 0, arguments);
    };
  }
  function Cr(l) {
    if (l != null) {
      try {
        return Ct.call(l);
      } catch {
      }
      try {
        return l + "";
      } catch {
      }
    }
    return "";
  }
  function bt(l, c) {
    return l === c || l !== l && c !== c;
  }
  var we = un(function() {
    return arguments;
  }()) ? un : function(l) {
    return nt(l) && Ee.call(l, "callee") && !nn.call(l, "callee");
  }, zt = Array.isArray;
  function jt(l) {
    return l != null && Ln(l.length) && !dt(l);
  }
  function Nt(l) {
    return nt(l) && jt(l);
  }
  var Gt = St || s;
  function dt(l) {
    if (!We(l))
      return !1;
    var c = et(l);
    return c == m || c == S || c == x || c == _;
  }
  function Ln(l) {
    return typeof l == "number" && l > -1 && l % 1 == 0 && l <= d;
  }
  function We(l) {
    var c = typeof l;
    return l != null && (c == "object" || c == "function");
  }
  function nt(l) {
    return l != null && typeof l == "object";
  }
  function Bn(l) {
    if (!nt(l) || et(l) != y)
      return !1;
    var c = tn(l);
    if (c === null)
      return !0;
    var g = Ee.call(c, "constructor") && c.constructor;
    return typeof g == "function" && g instanceof g && Ct.call(g) == Vn;
  }
  var Me = $ ? gt($) : Ne;
  function On(l) {
    return _n(l, Ut(l));
  }
  function Ut(l) {
    return jt(l) ? ye(l, !0) : fn(l);
  }
  var Rr = Tn(function(l, c, g) {
    An(l, c, g);
  });
  function mr(l) {
    return function() {
      return l;
    };
  }
  function o(l) {
    return l;
  }
  function s() {
    return !1;
  }
  e.exports = Rr;
})(Kr, Kr.exports);
var Tl = Kr.exports;
const ji = /* @__PURE__ */ Jr(Tl), Ni = {
  gap: {
    width: "1px",
    color: "rgb(230 230 230)"
  },
  paneContainer: {
    top: {},
    right: {},
    bottom: {},
    left: {}
  },
  cellContainer: {
    padding: {
      top: "2px",
      right: "2px",
      bottom: "2px",
      left: "2px"
    },
    background: "white"
  },
  area: {
    border: {
      color: "lightblue",
      style: "solid",
      width: "2px"
    }
  },
  focusIndicator: {
    background: "transparent",
    border: {
      color: "#3bb6df",
      style: "solid",
      width: "2px"
    }
  },
  fillHandle: {
    background: "transparent",
    border: {
      color: "black",
      style: "dashed",
      width: "2px"
    }
  },
  line: {
    backgroundColor: "lightblue",
    size: "3px"
  },
  shadow: {
    backgroundColor: "#E5E5E5AF"
  },
  resizeColumn: {
    default: {
      position: "absolute",
      top: 0,
      right: 0,
      background: "transparent",
      width: "5px",
      height: "100%"
    },
    hover: {
      backgroundColor: "lightblue"
    }
  },
  selectionIndicator: {
    background: "#add8e630",
    border: {
      color: "lightblue",
      style: "solid",
      width: "2px"
    }
  }
};
var Vr = { exports: {} };
Vr.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 9007199254740991, a = "[object Arguments]", d = "[object Array]", u = "[object Boolean]", I = "[object Date]", x = "[object Error]", h = "[object Function]", f = "[object GeneratorFunction]", C = "[object Map]", m = "[object Number]", S = "[object Object]", p = "[object Promise]", R = "[object RegExp]", v = "[object Set]", y = "[object String]", _ = "[object Symbol]", A = "[object WeakMap]", w = "[object ArrayBuffer]", E = "[object DataView]", L = "[object Float32Array]", j = "[object Float64Array]", F = "[object Int8Array]", W = "[object Int16Array]", Y = "[object Int32Array]", T = "[object Uint8Array]", B = "[object Uint8ClampedArray]", H = "[object Uint16Array]", M = "[object Uint32Array]", V = /[\\^$.*+?()[\]{}|]/g, Q = /\w*$/, be = /^\[object .+?Constructor\]$/, Xe = /^(?:0|[1-9]\d*)$/, q = {};
  q[a] = q[d] = q[w] = q[E] = q[u] = q[I] = q[L] = q[j] = q[F] = q[W] = q[Y] = q[C] = q[m] = q[S] = q[R] = q[v] = q[y] = q[_] = q[T] = q[B] = q[H] = q[M] = !0, q[x] = q[h] = q[A] = !1;
  var Jt = typeof Ye == "object" && Ye && Ye.Object === Object && Ye, Zt = typeof self == "object" && self && self.Object === Object && self, K = Jt || Zt || Function("return this")(), ht = t && !t.nodeType && t, Z = ht && !0 && e && !e.nodeType && e, He = Z && Z.exports === ht;
  function Lt(o, s) {
    return o.set(s[0], s[1]), o;
  }
  function pe(o, s) {
    return o.add(s), o;
  }
  function pt(o, s) {
    for (var l = -1, c = o ? o.length : 0; ++l < c && s(o[l], l, o) !== !1; )
      ;
    return o;
  }
  function ot(o, s) {
    for (var l = -1, c = s.length, g = o.length; ++l < c; )
      o[g + l] = s[l];
    return o;
  }
  function it(o, s, l, c) {
    var g = -1, b = o ? o.length : 0;
    for (c && b && (l = o[++g]); ++g < b; )
      l = s(l, o[g], g, o);
    return l;
  }
  function $(o, s) {
    for (var l = -1, c = Array(o); ++l < o; )
      c[l] = s(l);
    return c;
  }
  function at(o, s) {
    return o == null ? void 0 : o[s];
  }
  function ze(o) {
    var s = !1;
    if (o != null && typeof o.toString != "function")
      try {
        s = !!(o + "");
      } catch {
      }
    return s;
  }
  function gt(o) {
    var s = -1, l = Array(o.size);
    return o.forEach(function(c, g) {
      l[++s] = [g, c];
    }), l;
  }
  function Qt(o, s) {
    return function(l) {
      return o(s(l));
    };
  }
  function Sn(o) {
    var s = -1, l = Array(o.size);
    return o.forEach(function(c) {
      l[++s] = c;
    }), l;
  }
  var kn = Array.prototype, Kn = Function.prototype, Je = Object.prototype, wt = K["__core-js_shared__"], Ct = function() {
    var o = /[^.]+$/.exec(wt && wt.keys && wt.keys.IE_PROTO || "");
    return o ? "Symbol(src)_1." + o : "";
  }(), Ee = Kn.toString, Pe = Je.hasOwnProperty, Rt = Je.toString, Vn = RegExp(
    "^" + Ee.call(Pe).replace(V, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), mt = He ? K.Buffer : void 0, Ze = K.Symbol, Bt = K.Uint8Array, Ae = Qt(Object.getPrototypeOf, Object), en = Object.create, tn = Je.propertyIsEnumerable, yn = kn.splice, nn = Object.getOwnPropertySymbols, Ot = mt ? mt.isBuffer : void 0, je = Qt(Object.keys, Object), Qe = De(K, "DataView"), St = De(K, "Map"), Le = De(K, "Promise"), Pt = De(K, "Set"), $t = De(K, "WeakMap"), $e = De(Object, "create"), rn = we(Qe), _e = we(St), on = we(Le), an = we(Pt), ln = we($t), lt = Ze ? Ze.prototype : void 0, vn = lt ? lt.valueOf : void 0;
  function ge(o) {
    var s = -1, l = o ? o.length : 0;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function Yn() {
    this.__data__ = $e ? $e(null) : {};
  }
  function qn(o) {
    return this.has(o) && delete this.__data__[o];
  }
  function Xn(o) {
    var s = this.__data__;
    if ($e) {
      var l = s[o];
      return l === n ? void 0 : l;
    }
    return Pe.call(s, o) ? s[o] : void 0;
  }
  function bn(o) {
    var s = this.__data__;
    return $e ? s[o] !== void 0 : Pe.call(s, o);
  }
  function dn(o, s) {
    var l = this.__data__;
    return l[o] = $e && s === void 0 ? n : s, this;
  }
  ge.prototype.clear = Yn, ge.prototype.delete = qn, ge.prototype.get = Xn, ge.prototype.has = bn, ge.prototype.set = dn;
  function ae(o) {
    var s = -1, l = o ? o.length : 0;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function Jn() {
    this.__data__ = [];
  }
  function Zn(o) {
    var s = this.__data__, l = Mt(s, o);
    if (l < 0)
      return !1;
    var c = s.length - 1;
    return l == c ? s.pop() : yn.call(s, l, 1), !0;
  }
  function Qn(o) {
    var s = this.__data__, l = Mt(s, o);
    return l < 0 ? void 0 : s[l][1];
  }
  function er(o) {
    return Mt(this.__data__, o) > -1;
  }
  function tr(o, s) {
    var l = this.__data__, c = Mt(l, o);
    return c < 0 ? l.push([o, s]) : l[c][1] = s, this;
  }
  ae.prototype.clear = Jn, ae.prototype.delete = Zn, ae.prototype.get = Qn, ae.prototype.has = er, ae.prototype.set = tr;
  function se(o) {
    var s = -1, l = o ? o.length : 0;
    for (this.clear(); ++s < l; ) {
      var c = o[s];
      this.set(c[0], c[1]);
    }
  }
  function nr() {
    this.__data__ = {
      hash: new ge(),
      map: new (St || ae)(),
      string: new ge()
    };
  }
  function rr(o) {
    return vt(this, o).delete(o);
  }
  function or(o) {
    return vt(this, o).get(o);
  }
  function ir(o) {
    return vt(this, o).has(o);
  }
  function ar(o, s) {
    return vt(this, o).set(o, s), this;
  }
  se.prototype.clear = nr, se.prototype.delete = rr, se.prototype.get = or, se.prototype.has = ir, se.prototype.set = ar;
  function ye(o) {
    this.__data__ = new ae(o);
  }
  function sn() {
    this.__data__ = new ae();
  }
  function lr(o) {
    return this.__data__.delete(o);
  }
  function Dt(o) {
    return this.__data__.get(o);
  }
  function cn(o) {
    return this.__data__.has(o);
  }
  function dr(o, s) {
    var l = this.__data__;
    if (l instanceof ae) {
      var c = l.__data__;
      if (!St || c.length < r - 1)
        return c.push([o, s]), this;
      l = this.__data__ = new se(c);
    }
    return l.set(o, s), this;
  }
  ye.prototype.clear = sn, ye.prototype.delete = lr, ye.prototype.get = Dt, ye.prototype.has = cn, ye.prototype.set = dr;
  function et(o, s) {
    var l = Gt(o) || Nt(o) ? $(o.length, String) : [], c = l.length, g = !!c;
    for (var b in o)
      (s || Pe.call(o, b)) && !(g && (b == "length" || gr(b, c))) && l.push(b);
    return l;
  }
  function un(o, s, l) {
    var c = o[s];
    (!(Pe.call(o, s) && jt(c, l)) || l === void 0 && !(s in o)) && (o[s] = l);
  }
  function Mt(o, s) {
    for (var l = o.length; l--; )
      if (jt(o[l][0], s))
        return l;
    return -1;
  }
  function Ne(o, s) {
    return o && hn(s, Ut(s), o);
  }
  function fn(o, s, l, c, g, b, O) {
    var D;
    if (c && (D = b ? c(o, g, b, O) : c(o)), D !== void 0)
      return D;
    if (!Me(o))
      return o;
    var G = Gt(o);
    if (G) {
      if (D = pr(o), !s)
        return Ir(o, D);
    } else {
      var P = tt(o), k = P == h || P == f;
      if (We(o))
        return Ft(o, s);
      if (P == S || P == a || k && !b) {
        if (ze(o))
          return b ? o : {};
        if (D = Ue(k ? {} : o), !s)
          return En(o, Ne(D, o));
      } else {
        if (!q[P])
          return b ? o : {};
        D = pn(o, P, fn, s);
      }
    }
    O || (O = new ye());
    var ie = O.get(o);
    if (ie)
      return ie;
    if (O.set(o, D), !G)
      var X = l ? hr(o) : Ut(o);
    return pt(X || o, function(ce, fe) {
      X && (fe = ce, ce = o[fe]), un(D, fe, fn(ce, s, l, c, fe, o, O));
    }), D;
  }
  function An(o) {
    return Me(o) ? en(o) : {};
  }
  function sr(o, s, l) {
    var c = s(o);
    return Gt(o) ? c : ot(c, l(o));
  }
  function cr(o) {
    return Rt.call(o);
  }
  function ur(o) {
    if (!Me(o) || Cr(o))
      return !1;
    var s = nt(o) || ze(o) ? Vn : be;
    return s.test(we(o));
  }
  function fr(o) {
    if (!bt(o))
      return je(o);
    var s = [];
    for (var l in Object(o))
      Pe.call(o, l) && l != "constructor" && s.push(l);
    return s;
  }
  function Ft(o, s) {
    if (s)
      return o.slice();
    var l = new o.constructor(o.length);
    return o.copy(l), l;
  }
  function xn(o) {
    var s = new o.constructor(o.byteLength);
    return new Bt(s).set(new Bt(o)), s;
  }
  function yt(o, s) {
    var l = s ? xn(o.buffer) : o.buffer;
    return new o.constructor(l, o.byteOffset, o.byteLength);
  }
  function _n(o, s, l) {
    var c = s ? l(gt(o), !0) : gt(o);
    return it(c, Lt, new o.constructor());
  }
  function Tn(o) {
    var s = new o.constructor(o.source, Q.exec(o));
    return s.lastIndex = o.lastIndex, s;
  }
  function xr(o, s, l) {
    var c = s ? l(Sn(o), !0) : Sn(o);
    return it(c, pe, new o.constructor());
  }
  function Ht(o) {
    return vn ? Object(vn.call(o)) : {};
  }
  function In(o, s) {
    var l = s ? xn(o.buffer) : o.buffer;
    return new o.constructor(l, o.byteOffset, o.length);
  }
  function Ir(o, s) {
    var l = -1, c = o.length;
    for (s || (s = Array(c)); ++l < c; )
      s[l] = o[l];
    return s;
  }
  function hn(o, s, l, c) {
    l || (l = {});
    for (var g = -1, b = s.length; ++g < b; ) {
      var O = s[g], D = c ? c(l[O], o[O], O, l, o) : void 0;
      un(l, O, D === void 0 ? o[O] : D);
    }
    return l;
  }
  function En(o, s) {
    return hn(o, Ge(o), s);
  }
  function hr(o) {
    return sr(o, Ut, Ge);
  }
  function vt(o, s) {
    var l = o.__data__;
    return wr(s) ? l[typeof s == "string" ? "string" : "hash"] : l.map;
  }
  function De(o, s) {
    var l = at(o, s);
    return ur(l) ? l : void 0;
  }
  var Ge = nn ? Qt(nn, Object) : Rr, tt = cr;
  (Qe && tt(new Qe(new ArrayBuffer(1))) != E || St && tt(new St()) != C || Le && tt(Le.resolve()) != p || Pt && tt(new Pt()) != v || $t && tt(new $t()) != A) && (tt = function(o) {
    var s = Rt.call(o), l = s == S ? o.constructor : void 0, c = l ? we(l) : void 0;
    if (c)
      switch (c) {
        case rn:
          return E;
        case _e:
          return C;
        case on:
          return p;
        case an:
          return v;
        case ln:
          return A;
      }
    return s;
  });
  function pr(o) {
    var s = o.length, l = o.constructor(s);
    return s && typeof o[0] == "string" && Pe.call(o, "index") && (l.index = o.index, l.input = o.input), l;
  }
  function Ue(o) {
    return typeof o.constructor == "function" && !bt(o) ? An(Ae(o)) : {};
  }
  function pn(o, s, l, c) {
    var g = o.constructor;
    switch (s) {
      case w:
        return xn(o);
      case u:
      case I:
        return new g(+o);
      case E:
        return yt(o, c);
      case L:
      case j:
      case F:
      case W:
      case Y:
      case T:
      case B:
      case H:
      case M:
        return In(o, c);
      case C:
        return _n(o, c, l);
      case m:
      case y:
        return new g(o);
      case R:
        return Tn(o);
      case v:
        return xr(o, c, l);
      case _:
        return Ht(o);
    }
  }
  function gr(o, s) {
    return s = s ?? i, !!s && (typeof o == "number" || Xe.test(o)) && o > -1 && o % 1 == 0 && o < s;
  }
  function wr(o) {
    var s = typeof o;
    return s == "string" || s == "number" || s == "symbol" || s == "boolean" ? o !== "__proto__" : o === null;
  }
  function Cr(o) {
    return !!Ct && Ct in o;
  }
  function bt(o) {
    var s = o && o.constructor, l = typeof s == "function" && s.prototype || Je;
    return o === l;
  }
  function we(o) {
    if (o != null) {
      try {
        return Ee.call(o);
      } catch {
      }
      try {
        return o + "";
      } catch {
      }
    }
    return "";
  }
  function zt(o) {
    return fn(o, !0, !0);
  }
  function jt(o, s) {
    return o === s || o !== o && s !== s;
  }
  function Nt(o) {
    return Ln(o) && Pe.call(o, "callee") && (!tn.call(o, "callee") || Rt.call(o) == a);
  }
  var Gt = Array.isArray;
  function dt(o) {
    return o != null && Bn(o.length) && !nt(o);
  }
  function Ln(o) {
    return On(o) && dt(o);
  }
  var We = Ot || mr;
  function nt(o) {
    var s = Me(o) ? Rt.call(o) : "";
    return s == h || s == f;
  }
  function Bn(o) {
    return typeof o == "number" && o > -1 && o % 1 == 0 && o <= i;
  }
  function Me(o) {
    var s = typeof o;
    return !!o && (s == "object" || s == "function");
  }
  function On(o) {
    return !!o && typeof o == "object";
  }
  function Ut(o) {
    return dt(o) ? et(o) : fr(o);
  }
  function Rr() {
    return [];
  }
  function mr() {
    return !1;
  }
  e.exports = zt;
})(Vr, Vr.exports);
var El = Vr.exports;
const Ao = /* @__PURE__ */ Jr(El), Gi = (e) => {
  const t = Ao(Ni);
  return ji(t, e.styles);
}, Gn = (e, t, r, n) => {
  const i = Gi(e), a = Nn(i.gap.width || 0), d = kt(e, { rowIndex: t, colIndex: r }, "BottomCenter"), u = kt(e, { rowIndex: t, colIndex: r }, "TopCenter"), I = kt(e, { rowIndex: t, colIndex: r }, "Left"), x = kt(e, { rowIndex: t, colIndex: r }, "Right");
  u && (n == null || n.scrollBy({
    top: -u - a
  })), x && (n == null || n.scrollBy({
    left: x + a
  })), d && (n == null || n.scrollBy({
    top: d + a
  })), I && (n == null || n.scrollBy({
    left: -I - a
  }));
}, oe = (e, t, r) => {
  const n = document.getElementById(`ReactGrid-${e}`);
  if (!n)
    return null;
  const i = `rgHiddenFocusTarget rgFocusRowIdx-${t} rgFocusColIdx-${r}`, a = n.getElementsByClassName(i);
  return a.length > 0 ? a[0] : null;
}, Ll = (e, t) => {
  var a, d;
  if (t.rowIndex === 0)
    return (a = oe(e.id, t.rowIndex, t.colIndex)) == null || a.focus(), e;
  const r = le(e, t);
  if (!r)
    return e;
  const n = Rn(r, !0) ?? e.reactGridRef, i = "colSpan" in t && e.focusedLocation.colIndex !== -1 ? e.focusedLocation.colIndex : t.colIndex;
  for (let u = t.rowIndex - 1; u >= 0; u--) {
    const I = e.getCellByIndexes(u, i);
    if (I && (I == null ? void 0 : I.isFocusable) !== !1) {
      const x = Lr(e, I);
      return Wn("focuschange", { currentFocus: t }), Gn(e, u, i, n), (d = oe(e.id, x.rowIndex, x.colIndex)) == null || d.focus(), {
        selectedArea: z
      };
    }
  }
  return e;
}, ao = (e, t) => {
  var a, d;
  if (t.colIndex === e.columns.length - 1)
    return (a = oe(e.id, t.rowIndex, t.colIndex)) == null || a.focus(), e;
  const r = le(e, t);
  if (!r)
    return e;
  const n = Rn(r, !0) ?? e.reactGridRef, i = "rowSpan" in t && e.focusedLocation.rowIndex !== -1 ? e.focusedLocation.rowIndex : t.rowIndex;
  for (let u = t.colIndex + (t.colSpan ?? 1); u < e.columns.length; u++) {
    const I = e.getCellByIndexes(i, u);
    if (I && (I == null ? void 0 : I.isFocusable) !== !1) {
      const x = Lr(e, I);
      return Wn("focuschange", { currentFocus: t }), Gn(e, i, u, n), (d = oe(e.id, x.rowIndex, x.colIndex)) == null || d.focus(), {
        selectedArea: z
      };
    }
  }
  return e;
}, Ko = (e, t) => {
  var d, u, I;
  if (t.rowIndex === e.rows.length - 1)
    return (d = oe(e.id, t.rowIndex, t.colIndex)) == null || d.focus(), e;
  if (J(e, t).endRowIdx === e.rows.length)
    return (u = oe(e.id, t.rowIndex, t.colIndex)) == null || u.focus(), e;
  const n = le(e, t);
  if (!n)
    return e;
  const i = Rn(n, !0) ?? e.reactGridRef, a = "colSpan" in t && e.focusedLocation.colIndex !== -1 ? e.focusedLocation.colIndex : t.colIndex;
  for (let x = t.rowIndex + (t.rowSpan ?? 1); x < e.rows.length; x++) {
    const h = e.getCellByIndexes(x, a);
    if (h && (h == null ? void 0 : h.isFocusable) !== !1) {
      const f = Lr(e, h);
      return Wn("focuschange", { currentFocus: t }), Gn(e, x, a, i), (I = oe(e.id, f.rowIndex, f.colIndex)) == null || I.focus(), {
        selectedArea: z
      };
    }
  }
  return e;
}, Vo = (e, t) => {
  var a, d;
  if (t.colIndex === 0)
    return (a = oe(e.id, t.rowIndex, t.colIndex)) == null || a.focus(), e;
  const r = le(e, t);
  if (!r)
    return e;
  const n = Rn(r, !0) ?? e.reactGridRef, i = "rowSpan" in t && e.focusedLocation.rowIndex !== -1 ? e.focusedLocation.rowIndex : t.rowIndex;
  for (let u = t.colIndex - 1; u >= 0; u--) {
    const I = e.getCellByIndexes(i, u);
    if (I && (I == null ? void 0 : I.isFocusable) !== !1) {
      const x = Lr(e, I);
      return Wn("focuschange", { currentFocus: t }), Gn(e, i, u, n), (d = oe(e.id, x.rowIndex, x.colIndex)) == null || d.focus(), {
        selectedArea: z
      };
    }
  }
  return e;
}, Pn = (e, t, r) => {
  var n, i, a, d, u;
  switch (r) {
    case "right": {
      let I = t.colIndex, x = t.rowIndex, h = e.getCellOrSpanMemberByIndexes(x, I);
      do
        I++, I === e.selectedArea.endColIdx && (I = e.selectedArea.startColIdx, x++, x === e.selectedArea.endRowIdx && (x = e.selectedArea.startRowIdx)), h = e.getCellOrSpanMemberByIndexes(x, I);
      while (!h || Be(h) || (h == null ? void 0 : h.isFocusable) === !1);
      return (n = oe(e.id, x, I)) == null || n.focus(), e;
    }
    case "left": {
      let I = t.colIndex, x = t.rowIndex, h = e.getCellOrSpanMemberByIndexes(x, I);
      do
        I--, I === e.selectedArea.startColIdx - 1 && (I = e.selectedArea.endColIdx - 1, x--, x === e.selectedArea.startRowIdx - 1 && (x = e.selectedArea.endRowIdx - 1)), h = e.getCellOrSpanMemberByIndexes(x, I);
      while (!h || Be(h) || (h == null ? void 0 : h.isFocusable) === !1);
      return (i = oe(e.id, x, I)) == null || i.focus(), e;
    }
    case "down": {
      let I = t.colIndex, x = t.rowIndex, h = e.getCellOrSpanMemberByIndexes(x, I);
      do
        x++, x === e.selectedArea.endRowIdx && (x = e.selectedArea.startRowIdx, I++, I === e.selectedArea.endColIdx && (I = e.selectedArea.startColIdx)), h = e.getCellOrSpanMemberByIndexes(x, I);
      while (!h || Be(h) || (h == null ? void 0 : h.isFocusable) === !1);
      return (a = oe(e.id, x, I)) == null || a.focus(), e;
    }
    case "up": {
      let I = t.colIndex, x = t.rowIndex, h = e.getCellOrSpanMemberByIndexes(x, I);
      if (x === 0)
        return (d = oe(e.id, x, I)) == null || d.focus(), e;
      do
        x--, x === e.selectedArea.startRowIdx - 1 && (x = e.selectedArea.endRowIdx - 1, I--, I === e.selectedArea.startColIdx - 1 && (I = e.selectedArea.endColIdx - 1)), h = e.getCellOrSpanMemberByIndexes(x, I);
      while (!h || Be(h) || (h == null ? void 0 : h.isFocusable) === !1);
      return Wn("focuschange", { currentFocus: t }), (u = oe(e.id, x, I)) == null || u.focus(), e;
    }
  }
}, yr = (e, t, r, n = 1) => {
  const i = J(e, t), a = ue(e.selectedArea, z) ? { ...i } : { ...e.selectedArea };
  switch (r) {
    case "Left": {
      a.endColIdx > i.endColIdx ? (a.endColIdx -= n, de(e, t, a) || (a.endColIdx += n, n = 1, a.startColIdx -= n)) : a.startColIdx -= n;
      break;
    }
    case "Right": {
      a.startColIdx < t.colIndex ? (a.startColIdx += n, de(e, t, a) || (a.startColIdx -= n, n = 1, a.endColIdx += n)) : a.endColIdx += n;
      break;
    }
    case "Up": {
      a.endRowIdx > i.endRowIdx ? (a.endRowIdx -= n, de(e, t, a) || (a.endRowIdx += n, n = 1, a.startRowIdx -= n)) : a.startRowIdx -= n;
      break;
    }
    case "Down": {
      a.startRowIdx < t.rowIndex ? (a.startRowIdx += n, de(e, t, a) || (a.startRowIdx -= n, n = 1, a.endRowIdx += n)) : a.endRowIdx += n;
      break;
    }
  }
  const { columns: d, rows: u } = e, { startColIdx: I, endColIdx: x, startRowIdx: h, endRowIdx: f } = a;
  if (I < 0 || x < 0 || h < 0 || f < 0 || x > d.length || h > u.length || f > u.length || I > d.length)
    return e;
  if (ue(a, i))
    return {
      ...e,
      selectedArea: z
    };
  const m = me(e, a);
  return ue(m, e.selectedArea) ? yr(e, t, r, n + 1) : {
    ...e,
    selectedArea: {
      ...m
    }
  };
};
function Bl(e, t) {
  const { top: r, bottom: n, left: i, right: a } = e.getBoundingClientRect();
  return r >= 0 && i >= 0 && n <= (window.innerHeight || t.clientHeight) && a <= (window.innerWidth || t.clientWidth);
}
const Yo = (e, t) => {
  const r = e.reactGridRef;
  let n = 0;
  if (t === void 0)
    return 0;
  const i = e.getColumnCells(t);
  for (const a of i) {
    const d = le(e, a);
    d && Bl(d, r) && (de(e, a, e.paneRanges.Left) || de(e, a, e.paneRanges.Center) || de(e, a, e.paneRanges.Right)) && n++;
  }
  return n;
}, Wt = (e, t, r) => {
  const n = (i) => t.startRowIdx >= i.startRowIdx && t.endRowIdx <= i.endRowIdx && t.startColIdx >= i.startColIdx && t.endColIdx <= i.endColIdx;
  switch (r) {
    case "Left":
      return n(e.paneRanges.TopLeft) || n(e.paneRanges.Left) || n(e.paneRanges.BottomLeft);
    case "Right":
      return n(e.paneRanges.TopRight) || n(e.paneRanges.Right) || n(e.paneRanges.BottomRight);
    case "Top":
      return n(e.paneRanges.TopLeft) || n(e.paneRanges.TopCenter) || n(e.paneRanges.TopRight);
    case "Bottom":
      return n(e.paneRanges.BottomLeft) || n(e.paneRanges.BottomCenter) || n(e.paneRanges.BottomRight);
    default:
      return !1;
  }
}, Ol = {
  moveHorizontallyOnEnter: !1
}, Pl = (e, t, r = Ol) => {
  var a, d, u, I, x, h, f, C, m, S;
  let n = t.getFocusedCell();
  if (!n) {
    const p = t.getCellByIndexes(0, 0);
    if (!p)
      return t;
    n = {
      ...p
    };
  }
  const i = !ue(t.selectedArea, z) && de(t, n, t.selectedArea);
  if (e.shiftKey && (e.ctrlKey || e.metaKey))
    switch (e.key) {
      case "Home": {
        e.preventDefault();
        const p = J(t, n);
        return {
          ...t,
          selectedArea: {
            startRowIdx: 0,
            endRowIdx: p.endRowIdx,
            startColIdx: p.startColIdx,
            endColIdx: p.endColIdx
          }
        };
      }
      case "End": {
        e.preventDefault();
        const p = J(t, n);
        return {
          ...t,
          selectedArea: {
            startRowIdx: p.startRowIdx,
            endRowIdx: t.rows.length,
            startColIdx: p.startColIdx,
            endColIdx: p.endColIdx
          }
        };
      }
      case "ArrowUp": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          startRowIdx: 0
        });
        return { ...t, selectedArea: { ...v } };
      }
      case "ArrowDown": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          endRowIdx: t.rows.length
        });
        return { ...t, selectedArea: { ...v } };
      }
      case "ArrowLeft": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          startColIdx: 0
        });
        return { ...t, selectedArea: { ...v } };
      }
      case "ArrowRight": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          endColIdx: t.columns.length
        });
        return { ...t, selectedArea: { ...v } };
      }
      default:
        return t;
    }
  if (e.ctrlKey || e.metaKey)
    switch (e.key) {
      case "a": {
        e.preventDefault();
        const p = {
          startRowIdx: 0,
          endRowIdx: t.rows.length,
          startColIdx: 0,
          endColIdx: t.columns.length
        };
        return ue(t.selectedArea, p) ? {
          ...t,
          selectedArea: z
        } : {
          ...t,
          selectedArea: p
        };
      }
      case "Home":
        return e.preventDefault(), (a = oe(t.id, 0, 0)) == null || a.focus({ preventScroll: !0 }), t;
      case "End":
        return e.preventDefault(), (d = oe(t.id, t.rows.length - 1, t.columns.length - 1)) == null || d.focus({
          preventScroll: !0
        }), t;
      case "ArrowUp":
        return e.preventDefault(), n ? ((u = oe(t.id, 0, t.focusedLocation.colIndex)) == null || u.focus({ preventScroll: !0 }), { selectedArea: z }) : t;
      case "ArrowDown":
        return e.preventDefault(), n ? ((I = oe(t.id, t.rows.length - 1, t.focusedLocation.colIndex)) == null || I.focus({
          preventScroll: !0
        }), {
          selectedArea: z
        }) : t;
      case "ArrowLeft":
        return e.preventDefault(), n ? ((x = oe(t.id, t.focusedLocation.rowIndex, 0)) == null || x.focus({
          preventScroll: !0
        }), { selectedArea: z }) : t;
      case "ArrowRight":
        return e.preventDefault(), n ? ((h = oe(t.id, t.focusedLocation.rowIndex, t.columns.length - 1)) == null || h.focus({
          preventScroll: !0
        }), {
          selectedArea: z
        }) : t;
      case " ": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          startRowIdx: 0,
          endRowIdx: t.rows.length
        });
        return { ...t, selectedArea: { ...v } };
      }
      default:
        return t;
    }
  if (e.shiftKey)
    switch (e.key) {
      case "ArrowUp":
        return e.preventDefault(), yr(t, n, "Up");
      case "ArrowDown":
        return e.preventDefault(), yr(t, n, "Down");
      case "ArrowLeft":
        return e.preventDefault(), yr(t, n, "Left");
      case "ArrowRight":
        return e.preventDefault(), yr(t, n, "Right");
      case "PageUp": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        const R = Yo(t, n.colIndex);
        !ue(p, z) || (p = J(t, n));
        let y = -1, _ = -1;
        return p.startRowIdx === 0 ? t : (y = p.startRowIdx - R, y < 0 && (y = 0), Wt(t, p, "Top") ? _ = y : Wt(t, p, "Bottom") ? _ = p.startRowIdx === t.paneRanges.BottomCenter.startRowIdx ? y : t.paneRanges.BottomCenter.startRowIdx : p.startRowIdx === t.paneRanges.TopCenter.endRowIdx ? _ = 0 : p.startRowIdx - R <= t.paneRanges.TopCenter.endRowIdx ? _ = t.paneRanges.TopCenter.endRowIdx : _ = p.startRowIdx - R, {
          selectedArea: { ...me(t, {
            ...p,
            startRowIdx: _
          }) }
        });
      }
      case "PageDown": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        const R = Yo(t, n.colIndex);
        !ue(p, z) || (p = J(t, n));
        let y = -1, _ = -1;
        const A = t.rows.length, w = (f = t.getCellByIndexes(A - 1, n.colIndex)) == null ? void 0 : f.rowSpan;
        return p.endRowIdx === A ? t : (y = p.endRowIdx + R, p.endRowIdx + R > A && (y = A - (w ? w - 1 : 0)), Wt(t, p, "Top") ? _ = p.endRowIdx === t.paneRanges.TopCenter.endRowIdx ? y : t.paneRanges.TopCenter.endRowIdx : Wt(t, p, "Bottom") ? _ = y + 1 : p.endRowIdx === t.paneRanges.BottomCenter.startRowIdx ? _ = A - (w ? w - 1 : 0) : p.endRowIdx + R >= t.paneRanges.BottomCenter.startRowIdx ? _ = t.paneRanges.BottomCenter.startRowIdx : _ = p.endRowIdx + R, {
          selectedArea: { ...me(t, {
            ...p,
            endRowIdx: _
          }) }
        });
      }
      case "Home": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        if (!ue(p, z) || (p = J(t, n)), p.startColIdx === 0)
          return t;
        const v = ho(t, "Left");
        let y = -1;
        return Wt(t, p, "Left") && (y = 0), Wt(t, p, "Right") ? p.startColIdx === t.paneRanges.Right.startColIdx && (v ? y = t.paneRanges.Left.endColIdx : y = t.paneRanges.Right.startColIdx) : p.startColIdx === t.paneRanges.Left.endColIdx ? y = 0 : y = t.paneRanges.Left.endColIdx, {
          selectedArea: { ...me(t, {
            ...p,
            startColIdx: y
          }) }
        };
      }
      case "End": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = t.columns.length;
        if (p.endColIdx === v)
          return t;
        const y = ho(t, "Right");
        let _ = -1;
        return Wt(t, p, "Left") ? p.endColIdx === t.paneRanges.Left.endColIdx ? y ? _ = t.paneRanges.Right.startColIdx : _ = v : _ = t.paneRanges.Left.endColIdx : Wt(t, p, "Right") ? _ = v : p.endColIdx === t.paneRanges.Right.startColIdx ? y ? _ = t.paneRanges.Right.endColIdx : _ = v : _ = t.paneRanges.Right.startColIdx, {
          selectedArea: { ...me(t, {
            ...p,
            endColIdx: _
          }) }
        };
      }
      case " ": {
        e.preventDefault();
        let p = { ...t.selectedArea };
        !ue(p, z) || (p = J(t, n));
        const v = me(t, {
          ...p,
          startColIdx: 0,
          endColIdx: t.columns.length
        });
        return { ...t, selectedArea: { ...v } };
      }
      case "Enter":
        return e.preventDefault(), r.moveHorizontallyOnEnter ? Pn(t, n, "left") : Pn(t, n, "up");
    }
  switch (e.key) {
    case "Escape":
      return (C = oe(t.id, n.rowIndex, n.colIndex)) == null || C.focus({
        preventScroll: !0
      }), t;
    case "Backspace":
    case "Delete": {
      let p = t.selectedArea;
      ue(p, z) && (p = J(t, n));
      const R = [];
      for (let v = p.startRowIdx; v < p.endRowIdx; v++)
        for (let y = p.startColIdx; y < p.endColIdx; y++) {
          const _ = t.cellsLookup.get(`${v} ${y}`);
          _ && R.push(_);
        }
      return R.forEach((v) => v.onStringValueReceived("")), t;
    }
    case "Tab":
      return e.preventDefault(), e.shiftKey ? i ? Pn(t, n, "left") : Vo(t, n) : i ? Pn(t, n, "right") : ao(t, n);
    case "Enter": {
      e.preventDefault();
      const p = de(t, n, t.selectedArea);
      return r.moveHorizontallyOnEnter ? p ? Pn(t, n, "right") : ao(t, n) : p ? Pn(t, n, "down") : Ko(t, n);
    }
    case "ArrowUp":
      return e.preventDefault(), Ll(t, n);
    case "ArrowDown":
      return e.preventDefault(), Ko(t, n);
    case "ArrowLeft":
      return e.preventDefault(), Vo(t, n);
    case "ArrowRight":
      return e.preventDefault(), ao(t, n);
    case "Home":
      return e.preventDefault(), (m = oe(t.id, n.rowIndex, 0)) == null || m.focus({
        preventScroll: !0
      }), {
        // If any area is selected, remove it.
        selectedArea: z
      };
    case "End":
      return e.preventDefault(), (S = oe(t.id, n.rowIndex, t.columns.length - 1)) == null || S.focus({
        preventScroll: !0
      }), {
        // If any area is selected, remove it.
        selectedArea: z
      };
    case "PageUp":
      return e.preventDefault(), t;
    default:
      return t;
  }
}, $l = (e) => {
  const { selectedArea: t, getCellByIndexes: r } = e;
  let n = 0;
  for (let i = t.startColIdx; i < t.endColIdx; ) {
    const a = r(0, i);
    if (a) {
      const d = le(e, a);
      d && (n += d.offsetWidth), i += a.colSpan ? a.colSpan : 1;
    } else
      i++;
  }
  return n;
}, Ui = (e) => {
  const t = e.getCellByIndexes(0, e.columns.length - 1), r = le(e, t), n = r.offsetLeft, i = r.offsetWidth;
  return {
    lastColumnRelativeffsetLeft: n,
    lastColumnClientOffsetLeft: r.getBoundingClientRect().left,
    lastColumnCellWidth: i
  };
}, _o = (e, t) => {
  const r = document.getElementById(`ReactGrid-${e}`);
  if (!r || !r.contains(t))
    return { rowIndex: -1, colIndex: -1 };
  const n = t.className.split(" ");
  let i = null, a = null;
  return n.forEach((d) => {
    d.startsWith("rgFocusRowIdx-") ? i = parseInt(d.split("-")[1], 10) : d.startsWith("rgFocusColIdx-") && (a = parseInt(d.split("-")[1], 10));
  }), i !== null && a !== null ? { rowIndex: i, colIndex: a } : { rowIndex: -1, colIndex: -1 };
}, Ve = (e, t) => {
  const r = e.getRowAmount();
  for (let n = 0; n < r; n++) {
    const i = e.cells.get(`${n} ${t}`);
    if (!i)
      continue;
    const a = J(e, i);
    if ("originColIndex" in i && a.endColIdx - a.startColIdx > 1 && t !== i.originColIndex)
      return i;
  }
};
qt();
let Mn = 0, Gr = 0, xe = 0;
const wn = {
  id: "ColumnReorder",
  handlePointerDown: function(e, t) {
    return t;
  },
  handlePointerMove: (e, t) => qo(t, e),
  handlePointerUp: function(e, t) {
    return Xo(t, e);
  },
  handlePointerHold: function(e, t) {
    return t;
  },
  handleFocus: (e, t) => {
    const r = document.activeElement;
    if (!r)
      return t;
    const { rowIndex: n, colIndex: i } = _o(t.id, r);
    return n === -1 || i === -1 ? t : {
      focusedLocation: { rowIndex: n, colIndex: i }
    };
  },
  handlePointerHoldTouch: function(e, t) {
    return t;
  },
  handlePointerDownTouch: function(e, t) {
    return t;
  },
  handlePointerMoveTouch: function(e, t) {
    return qo(t, e);
  },
  handlePointerUpTouch: function(e, t) {
    return Xo(t, e);
  }
}, qo = (e, t) => {
  var j, F;
  Mn || (Mn = t.clientX);
  const { rowIndex: r, colIndex: n } = jn(t.clientX, t.clientY), i = e.getCellByIndexes(r, n);
  i && rt(e, i, { rowIndex: r, colIndex: n }, !0);
  const a = $l(e), { lastColumnRelativeffsetLeft: d, lastColumnCellWidth: u } = Ui(e), I = e.getCellByIndexes(0, e.selectedArea.startColIdx);
  if (!I)
    return e;
  const x = le(e, I);
  if (!x)
    return e;
  const h = x.offsetLeft || 0, f = (F = (j = e.reactGridRef) == null ? void 0 : j.getBoundingClientRect()) == null ? void 0 : F.left;
  if (f === void 0)
    return e;
  Gr || (Gr = t.clientX - f - h);
  let C = t.clientX - f - Gr;
  const m = Nn(Gi(e).gap.width || 0), S = Et(t.clientX, x.getBoundingClientRect().top);
  if (!S)
    return e;
  const p = Cn(S);
  if (!p)
    return e;
  const R = me(e, {
    startRowIdx: 0,
    endRowIdx: e.rows.length,
    startColIdx: p.colIndex,
    endColIdx: p.colIndex + 1
  }), v = e.getCellByIndexes(R.startRowIdx, R.startColIdx), y = e.getCellByIndexes(R.startRowIdx, R.endColIdx - 1);
  if (!v || !y)
    return e;
  const _ = le(e, v), A = le(e, y);
  if (!_ || !A)
    return e;
  let w;
  const E = e.selectedArea.startColIdx < e.paneRanges.Left.endColIdx && e.selectedArea.endColIdx > e.paneRanges.Left.endColIdx, L = e.selectedArea.startColIdx < e.paneRanges.Right.startColIdx && e.selectedArea.endColIdx > e.paneRanges.Right.startColIdx;
  if (E || L)
    w = void 0;
  else if (t.clientX > x.getBoundingClientRect().left + a)
    if (xe = R.endColIdx - 1, kt(e, { rowIndex: 0, colIndex: xe }, "Right"))
      w = void 0;
    else {
      const W = e.selectedArea.endColIdx - e.selectedArea.startColIdx, Y = xe + 1 - W;
      if (Tt(e, y, "TopRight"))
        if (Y >= e.paneRanges.Right.startColIdx) {
          let T;
          e.selectedArea.startColIdx < e.paneRanges.TopLeft.endColIdx && (T = Ve(
            e,
            e.paneRanges.TopLeft.endColIdx + W
          ));
          let B;
          e.selectedArea.endColIdx <= e.paneRanges.Right.startColIdx && (B = Ve(
            e,
            e.paneRanges.Right.startColIdx + W
          )), !T && !B && (w = A.offsetLeft + A.offsetWidth);
        } else {
          let T;
          e.selectedArea.startColIdx < e.paneRanges.TopLeft.endColIdx && (T = Ve(
            e,
            e.paneRanges.Left.endColIdx + W
          )), !Ve(
            e,
            e.selectedArea.endColIdx - (xe + 1 - e.paneRanges.Right.startColIdx)
          ) && !T && (w = A.offsetLeft + A.offsetWidth);
        }
      else if (e.selectedArea.startColIdx < e.paneRanges.TopLeft.endColIdx && xe + 1 > e.paneRanges.TopLeft.endColIdx)
        if (Y === e.paneRanges.TopLeft.endColIdx)
          w = A.offsetLeft + A.offsetWidth;
        else if (Y < e.paneRanges.TopLeft.endColIdx)
          Ve(
            e,
            e.selectedArea.endColIdx - (xe + 1 - e.paneRanges.TopLeft.endColIdx)
          ) || (w = A.offsetLeft + A.offsetWidth);
        else {
          const T = Ve(
            e,
            e.paneRanges.TopLeft.endColIdx + W
          );
          (!T || "originColIndex" in T && T.originColIndex + W === e.paneRanges.TopLeft.endColIdx) && (w = A.offsetLeft + A.offsetWidth);
        }
      else
        w = A.offsetLeft + A.offsetWidth;
    }
  else if (t.clientX < x.getBoundingClientRect().left - 1)
    if (xe = R.startColIdx, kt(e, { rowIndex: 0, colIndex: xe }, "Left"))
      w = void 0;
    else {
      const W = e.selectedArea.endColIdx - e.selectedArea.startColIdx, Y = xe + W;
      if (Tt(e, v, "TopLeft"))
        if (e.selectedArea.endColIdx <= e.paneRanges.Left.endColIdx)
          w = _.offsetLeft - m;
        else if (Y <= e.paneRanges.Left.endColIdx) {
          let T;
          e.selectedArea.endColIdx > e.paneRanges.Right.startColIdx && (T = Ve(
            e,
            e.paneRanges.Right.startColIdx - W
          ));
          const B = Ve(
            e,
            e.paneRanges.Left.endColIdx - W
          );
          (!B && !T || B && Y === e.paneRanges.Left.endColIdx) && (w = _.offsetLeft - m);
        } else {
          let T;
          e.selectedArea.endColIdx > e.paneRanges.Right.startColIdx && (T = Ve(
            e,
            e.paneRanges.Right.startColIdx - W
          )), !Ve(
            e,
            e.selectedArea.startColIdx + (e.paneRanges.Left.endColIdx - xe)
          ) && !T && (w = _.offsetLeft - m);
        }
      else if (e.selectedArea.endColIdx > e.paneRanges.TopRight.startColIdx)
        if (xe >= e.paneRanges.TopRight.startColIdx)
          w = _.offsetLeft - m;
        else if (Y > e.paneRanges.TopRight.startColIdx)
          Ve(
            e,
            e.selectedArea.endColIdx - (Y - e.paneRanges.TopRight.startColIdx)
          ) || (w = _.offsetLeft - m);
        else {
          const T = Ve(
            e,
            e.paneRanges.TopRight.startColIdx - W
          );
          (!T || "originColIndex" in T && T.originColIndex - W === e.paneRanges.TopRight.startColIdx) && (w = _.offsetLeft - m);
        }
      else
        w = _.offsetLeft - m;
    }
  return C < 0 && (C = 0), C + a >= d + u && (C = d + u - a), {
    ...e,
    shadowSize: a,
    shadowPosition: C,
    linePosition: w
  };
}, Xo = (e, t) => {
  var f, C, m;
  if (Gr = 0, !Mn)
    return { ...e, currentBehavior: e.getBehavior("Default") };
  if (!e.linePosition === void 0 && (Mn = 0, !Mn))
    return {
      ...e,
      currentBehavior: e.getBehavior("Default"),
      shadowPosition: void 0,
      shadowSize: void 0
    };
  Mn = 0;
  const r = Array.from(
    { length: e.selectedArea.endColIdx - e.selectedArea.startColIdx },
    (S, p) => p + e.selectedArea.startColIdx
  ), n = !!r.find((S) => S > xe), i = r.includes(e.focusedLocation.colIndex);
  let a = e.focusedLocation;
  if (i) {
    const S = e.focusedLocation.colIndex - e.selectedArea.startColIdx;
    a = {
      rowIndex: e.focusedLocation.rowIndex,
      colIndex: n ? xe + S : xe - (r.length - 1) + S
    };
  } else if (n && e.selectedArea.startColIdx > e.focusedLocation.colIndex && xe <= e.focusedLocation.colIndex) {
    const S = e.selectedArea.endColIdx - e.selectedArea.startColIdx;
    a = {
      rowIndex: e.focusedLocation.rowIndex,
      colIndex: e.focusedLocation.colIndex + S
    };
  } else if (!n && e.selectedArea.endColIdx <= e.focusedLocation.colIndex && xe >= e.focusedLocation.colIndex) {
    const S = e.selectedArea.endColIdx - e.selectedArea.startColIdx;
    a = {
      rowIndex: e.focusedLocation.rowIndex,
      colIndex: e.focusedLocation.colIndex - S
    };
  }
  const { lastColumnCellWidth: d, lastColumnClientOffsetLeft: u } = Ui(e);
  if (t.clientX > u + d) {
    try {
      (f = e.onColumnReorder) == null || f.call(e, r, e.columns.length - 1);
    } catch {
    }
    return {
      currentBehavior: e.getBehavior("Default"),
      changedFocusedLocation: a,
      selectedArea: {
        startRowIdx: 0,
        endRowIdx: e.rows.length,
        startColIdx: e.columns.length - 1 - (r.length - 1),
        endColIdx: e.columns.length
      },
      shadowPosition: void 0,
      linePosition: void 0,
      shadowSize: void 0
    };
  }
  const I = e.reactGridRef;
  if (!I)
    return e;
  if (t.clientX < I.getBoundingClientRect().left) {
    try {
      (C = e.onColumnReorder) == null || C.call(e, r, 0);
    } catch {
    }
    return {
      currentBehavior: e.getBehavior("Default"),
      changedFocusedLocation: a,
      selectedArea: {
        startRowIdx: 0,
        endRowIdx: e.rows.length,
        startColIdx: 0,
        endColIdx: 0 + r.length
      },
      shadowPosition: void 0,
      linePosition: void 0,
      shadowSize: void 0
    };
  }
  const x = e.getCellByIndexes(0, e.selectedArea.startColIdx);
  if (!x || !le(e, x))
    return e;
  try {
    (m = e.onColumnReorder) == null || m.call(e, r, xe);
  } catch {
  }
  return {
    currentBehavior: e.getBehavior("Default"),
    changedFocusedLocation: a,
    selectedArea: {
      startRowIdx: 0,
      endRowIdx: e.rows.length,
      startColIdx: n ? xe : xe - (r.length - 1),
      endColIdx: n ? xe + r.length : xe + 1
    },
    shadowPosition: void 0,
    linePosition: void 0,
    shadowSize: void 0
  };
}, Dl = (e) => {
  const { selectedArea: t, getCellByIndexes: r } = e;
  let n = 0;
  for (let i = t.startRowIdx; i < t.endRowIdx; i++) {
    const a = r(i, 0);
    if (a) {
      const d = le(e, a);
      d && (n += d.offsetHeight);
    }
  }
  return n;
}, Wi = (e) => {
  const t = e.getCellByIndexes(e.rows.length - 1, 0), r = le(e, t), n = r.offsetTop, i = r.offsetHeight;
  return {
    lastRowRelativeOffsetTop: n,
    lastRowClientOffsetTop: r.getBoundingClientRect().top,
    lastRowHeight: i
  };
}, st = (e, t) => {
  const r = e.getColumnAmount();
  for (let n = 0; n < r; n++) {
    const i = e.cells.get(`${t} ${n}`);
    if (!i)
      continue;
    const a = J(e, i);
    if ("originRowIndex" in i && a.endRowIdx - a.startRowIdx > 1 && t !== i.originRowIndex)
      return i;
  }
};
qt();
let Fn = 0, Ur = 0, Ie = 0;
const _t = {
  id: "RowReorder",
  handlePointerDown: function(e, t) {
    return t;
  },
  handlePointerMove: (e, t) => Jo(t, e),
  handlePointerUp: function(e, t) {
    return Zo(t, e);
  },
  handleFocus: (e, t) => {
    const r = document.activeElement;
    if (!r)
      return t;
    const { rowIndex: n, colIndex: i } = _o(t.id, r);
    return n === -1 || i === -1 ? t : {
      focusedLocation: { rowIndex: n, colIndex: i }
    };
  },
  handlePointerHold: function(e, t) {
    return t;
  },
  handlePointerHoldTouch: function(e, t) {
    return t;
  },
  handlePointerDownTouch: function(e, t) {
    return t;
  },
  handlePointerMoveTouch: function(e, t) {
    return Jo(t, e);
  },
  handlePointerUpTouch: function(e, t) {
    return Zo(t, e);
  }
}, Jo = (e, t) => {
  var T, B;
  Fn || (Fn = t.clientY);
  const r = e.getCellByIndexes(0, 0);
  if (!r)
    return e;
  const n = le(e, r);
  if (!n)
    return e;
  const i = n.getBoundingClientRect().left, { rowIndex: a, colIndex: d } = jn(i, t.clientY), u = e.getCellByIndexes(a, d);
  u && rt(e, u, { rowIndex: a, colIndex: d }, !1, !0);
  const I = Dl(e), { lastRowRelativeOffsetTop: x, lastRowHeight: h } = Wi(e), f = e.getCellByIndexes(e.selectedArea.startRowIdx, 0);
  if (!f)
    return e;
  const C = le(e, f);
  if (!C)
    return e;
  const m = C.offsetTop || 0, S = (B = (T = e.reactGridRef) == null ? void 0 : T.getBoundingClientRect()) == null ? void 0 : B.top;
  if (S === void 0)
    return e;
  Ur || (Ur = t.clientY - S - m);
  let p = t.clientY - S - Ur;
  const R = Et(C.getBoundingClientRect().left, t.clientY);
  if (!R)
    return e;
  const v = Cn(R), y = e.getCellByIndexes(v.rowIndex, v.colIndex);
  if (!y)
    return e;
  const _ = J(e, y), A = me(e, {
    startRowIdx: _.startRowIdx,
    endRowIdx: _.endRowIdx,
    startColIdx: 0,
    endColIdx: e.columns.length
  }), w = e.getCellByIndexes(A.startRowIdx, A.startColIdx), E = e.getCellByIndexes(A.endRowIdx - 1, A.startColIdx);
  if (!w || !E)
    return e;
  const L = le(e, w), j = le(e, E);
  if (!L || !j)
    return e;
  let F;
  const W = e.selectedArea.startRowIdx < e.paneRanges.BottomLeft.startRowIdx && e.selectedArea.endRowIdx > e.paneRanges.BottomLeft.startRowIdx, Y = e.selectedArea.startRowIdx < e.paneRanges.TopLeft.endRowIdx && e.selectedArea.endRowIdx > e.paneRanges.TopLeft.endRowIdx;
  if (W || Y)
    F = void 0;
  else if (t.clientY > C.getBoundingClientRect().top + I)
    if (Ie = A.endRowIdx - 1, kt(e, { rowIndex: Ie, colIndex: 0 }, "BottomCenter"))
      F = void 0;
    else {
      const H = e.selectedArea.endRowIdx - e.selectedArea.startRowIdx, M = Ie + 1 - H;
      if (Tt(e, E, "BottomLeft"))
        if (M >= e.paneRanges.BottomLeft.startRowIdx) {
          let V;
          e.selectedArea.startRowIdx < e.paneRanges.TopLeft.endRowIdx && (V = st(
            e,
            e.paneRanges.TopLeft.endRowIdx + H
          ));
          let Q;
          e.selectedArea.endRowIdx <= e.paneRanges.BottomLeft.startRowIdx && (Q = st(
            e,
            e.paneRanges.BottomLeft.startRowIdx + H
          )), !V && !Q && (F = j.offsetTop + j.offsetHeight);
        } else {
          let V;
          e.selectedArea.startRowIdx < e.paneRanges.TopLeft.endRowIdx && (V = st(
            e,
            e.paneRanges.TopLeft.endRowIdx + H
          )), !st(
            e,
            e.selectedArea.endRowIdx - (Ie + 1 - e.paneRanges.BottomCenter.startRowIdx)
          ) && !V && (F = j.offsetTop + j.offsetHeight);
        }
      else if (e.selectedArea.startRowIdx < e.paneRanges.TopLeft.endRowIdx && Ie + 1 > e.paneRanges.TopLeft.endRowIdx)
        if (M === e.paneRanges.TopLeft.endRowIdx)
          F = j.offsetTop + j.offsetHeight;
        else if (M < e.paneRanges.TopLeft.endRowIdx)
          st(
            e,
            e.selectedArea.endRowIdx - (Ie + 1 - e.paneRanges.TopLeft.endRowIdx)
          ) || (F = j.offsetTop + j.offsetHeight);
        else {
          const V = st(
            e,
            e.paneRanges.TopLeft.endRowIdx + H
          );
          (!V || "originRowIndex" in V && V.originRowIndex - H === e.paneRanges.TopLeft.endRowIdx) && (F = j.offsetTop + j.offsetHeight);
        }
      else
        F = j.offsetTop + j.offsetHeight;
    }
  else if (t.clientY < C.getBoundingClientRect().top - 1)
    if (Ie = A.startRowIdx, kt(e, { rowIndex: Ie, colIndex: 0 }, "TopCenter"))
      F = void 0;
    else {
      const H = e.selectedArea.endRowIdx - e.selectedArea.startRowIdx, M = Ie + H;
      if (Tt(e, w, "TopLeft")) {
        if (e.selectedArea.endRowIdx <= e.paneRanges.TopLeft.endRowIdx)
          F = L.offsetTop;
        else if (M <= e.paneRanges.TopLeft.endRowIdx) {
          let V;
          e.selectedArea.endRowIdx > e.paneRanges.BottomLeft.startRowIdx && (V = st(
            e,
            e.paneRanges.BottomLeft.startRowIdx - H
          ));
          const Q = st(
            e,
            e.paneRanges.TopLeft.endRowIdx - H
          );
          (!Q && !V || Q && "originRowIndex" in Q && Q.originRowIndex + H === e.paneRanges.TopLeft.endRowIdx) && (F = L.offsetTop);
        }
      } else
        e.selectedArea.endRowIdx > e.paneRanges.BottomLeft.startRowIdx && Ie < e.paneRanges.BottomLeft.startRowIdx ? M > e.paneRanges.BottomLeft.startRowIdx ? st(
          e,
          e.selectedArea.startRowIdx + (e.paneRanges.BottomLeft.startRowIdx - Ie)
        ) || (F = L.offsetTop) : st(
          e,
          e.paneRanges.BottomLeft.startRowIdx - H
        ) || (F = L.offsetTop) : F = L.offsetTop;
    }
  return p < 0 && (p = 0), p + I >= x + h && (p = x + h - I), e.rows[a].reorderable ? {
    ...e,
    shadowSize: I,
    shadowPosition: p,
    linePosition: F
  } : {
    ...e,
    shadowSize: I,
    shadowPosition: p,
    linePosition: void 0
  };
}, Zo = (e, t) => {
  var f, C, m;
  if (Ur = 0, !Fn)
    return { ...e, lineOrientation: "vertical", currentBehavior: e.getBehavior("Default") };
  if (!e.linePosition && (Fn = 0, !Fn))
    return {
      ...e,
      currentBehavior: e.getBehavior("Default"),
      shadowPosition: void 0,
      lineOrientation: "vertical",
      shadowSize: void 0
    };
  Fn = 0;
  const r = Array.from(
    { length: e.selectedArea.endRowIdx - e.selectedArea.startRowIdx },
    (S, p) => p + e.selectedArea.startRowIdx
  ), n = !!r.find((S) => S > Ie), i = r.includes(e.focusedLocation.rowIndex);
  let a = e.focusedLocation;
  if (i) {
    const S = e.focusedLocation.rowIndex - e.selectedArea.startRowIdx;
    a = {
      rowIndex: n ? Ie + S : Ie - (r.length - 1) + S,
      colIndex: e.focusedLocation.colIndex
    };
  } else if (n && e.selectedArea.startRowIdx > e.focusedLocation.rowIndex && Ie <= e.focusedLocation.rowIndex) {
    const S = e.selectedArea.endRowIdx - e.selectedArea.startRowIdx;
    a = {
      rowIndex: e.focusedLocation.rowIndex + S,
      colIndex: e.focusedLocation.colIndex
    };
  } else if (!n && e.selectedArea.endRowIdx <= e.focusedLocation.rowIndex && Ie >= e.focusedLocation.rowIndex) {
    const S = e.selectedArea.endRowIdx - e.selectedArea.startRowIdx;
    a = {
      rowIndex: e.focusedLocation.rowIndex - S,
      colIndex: e.focusedLocation.colIndex
    };
  }
  const { lastRowHeight: d, lastRowClientOffsetTop: u } = Wi(e);
  if (t.clientY > u + d) {
    try {
      (f = e.onRowReorder) == null || f.call(e, r, e.rows.length - 1);
    } catch {
    }
    return {
      currentBehavior: e.getBehavior("Default"),
      changedFocusedLocation: a,
      selectedArea: {
        startRowIdx: e.rows.length - 1 - (r.length - 1),
        endRowIdx: e.rows.length,
        startColIdx: 0,
        endColIdx: e.columns.length
      },
      shadowPosition: void 0,
      linePosition: void 0,
      lineOrientation: "vertical",
      shadowSize: void 0
    };
  }
  const I = e.reactGridRef;
  if (!I)
    return e;
  if (t.clientY < I.getBoundingClientRect().top) {
    try {
      (C = e.onRowReorder) == null || C.call(e, r, 0);
    } catch {
    }
    return {
      currentBehavior: e.getBehavior("Default"),
      changedFocusedLocation: a,
      selectedArea: {
        startRowIdx: 0,
        endRowIdx: 0 + r.length,
        startColIdx: 0,
        endColIdx: e.columns.length
      },
      shadowPosition: void 0,
      linePosition: void 0,
      lineOrientation: "vertical",
      shadowSize: void 0
    };
  }
  const x = e.getCellByIndexes(e.selectedArea.startRowIdx, 0);
  if (!x || !le(e, x))
    return e;
  try {
    (m = e.onRowReorder) == null || m.call(e, r, Ie);
  } catch {
  }
  return {
    currentBehavior: e.getBehavior("Default"),
    changedFocusedLocation: a,
    selectedArea: {
      startRowIdx: n ? Ie : Ie - (r.length - 1),
      endRowIdx: n ? Ie + r.length : Ie + 1,
      startColIdx: 0,
      endColIdx: e.columns.length
    },
    shadowPosition: void 0,
    linePosition: void 0,
    lineOrientation: "vertical",
    shadowSize: void 0
  };
};
function Qo(e, t) {
  const r = e.cells;
  for (let n = t.startColIdx; n < t.endColIdx; n++) {
    const i = r.get(`0 ${n}`);
    if (!i)
      return e.selectedArea;
    if (Be(i)) {
      const a = e.getCellByIndexes(i.originRowIndex, i.originColIndex);
      if (a && (a.isSelectable === !1 || a.isFocusable === !1))
        return e.selectedArea;
    } else if (i.isSelectable === !1 || i.isFocusable === !1)
      return e.selectedArea;
  }
  return me(e, {
    startRowIdx: 0,
    endRowIdx: e.rows.length,
    startColIdx: t.startColIdx,
    endColIdx: t.endColIdx
  });
}
function ei(e, t) {
  const r = e.cells;
  for (let n = t.startRowIdx; n < t.endRowIdx; n++) {
    const i = r.get(`${n} 0`);
    if (!i)
      return e.selectedArea;
    if (Be(i)) {
      const a = e.getCellByIndexes(i.originRowIndex, i.originColIndex);
      if (a && (a.isSelectable === !1 || a.isFocusable === !1))
        return e.selectedArea;
    } else if (i.isSelectable === !1 || i.isFocusable === !1)
      return e.selectedArea;
  }
  return me(e, {
    startRowIdx: t.startRowIdx,
    endRowIdx: t.endRowIdx,
    startColIdx: 0,
    endColIdx: e.columns.length
  });
}
function Dr(e, t, r) {
  switch (t) {
    case "row":
      return de(e, r, e.selectedArea) && e.selectedArea.endColIdx === e.columns.length && !!e.onRowReorder && !!e.rows[r.rowIndex].reorderable;
    case "column":
      return de(e, r, e.selectedArea) && e.selectedArea.endRowIdx === e.rows.length && !!e.onColumnReorder && !!e.columns[r.colIndex].reorderable;
  }
}
const po = (e) => e === _t.id || e === wn.id;
function ti(e, t) {
  var n;
  if (!e.reactGridRef)
    return;
  const r = (n = e.reactGridRef) == null ? void 0 : n.getElementsByClassName(
    `rgRowIdx-${t.rowIndex} rgColIdx-${t.colIndex}`
  );
  if (!(!r || (r == null ? void 0 : r.length) === 0)) {
    if ((r == null ? void 0 : r.length) !== 1)
      throw new Error("Cell container is not unique!");
    return r[0];
  }
}
qt();
let Mr = !1;
const go = () => ({
  id: "Default",
  handlePointerDown: function(e, t) {
    var m;
    const r = Et(e.clientX, e.clientY);
    if (!r)
      return t;
    const { rowIndex: n, colIndex: i } = Dn(r), a = Rn(r, !0) ?? t.reactGridRef;
    Gn(t, n, i, a);
    const d = t.getCellByIndexes(n, i);
    if (!d)
      return t;
    const u = n === 0 && t.enableColumnSelectionOnFirstRow, I = i === 0 && t.enableRowSelectionOnFirstColumn;
    let x = !0;
    u ? t.selectedArea.endRowIdx === t.rows.length && (x = !de(t, d, t.selectedArea)) : I && t.selectedArea.endColIdx === t.columns.length && (x = !de(t, d, t.selectedArea));
    const h = J(t, d);
    let f = t.currentBehavior, C = z;
    if (u ? (Dr(t, "column", d) && (f = wn), f.id !== wn.id && (C = Qo(t, h))) : I && (Dr(t, "row", d) && (f = _t), f.id !== _t.id && (C = ei(t, h))), Mr) {
      const S = t.getFocusedCell();
      if (!S)
        return t;
      const p = J(t, S), R = {
        startRowIdx: Math.min(p.startRowIdx, h.startRowIdx),
        endRowIdx: Math.max(p.endRowIdx, h.endRowIdx),
        startColIdx: Math.min(p.startColIdx, h.startColIdx),
        endColIdx: Math.max(p.endColIdx, h.endColIdx)
      };
      return Mr = !1, { selectedArea: R };
    }
    return x ? ((d == null ? void 0 : d.isFocusable) !== !1 && ((m = oe(t.id, n, i)) == null || m.focus({ preventScroll: !0 })), {
      selectedArea: C,
      pointerStartIdx: { rowIndex: n, colIndex: i }
    }) : po(f.id) ? {
      ...f.id === _t.id && { lineOrientation: "horizontal" },
      currentBehavior: f,
      pointerStartIdx: { rowIndex: n, colIndex: i }
    } : { pointerStartIdx: { rowIndex: n, colIndex: i } };
  },
  handleFocus: (e, t) => {
    const r = document.activeElement;
    if (!r)
      return t;
    const { rowIndex: n, colIndex: i } = _o(t.id, r);
    return n === -1 || i === -1 ? t : {
      focusedLocation: { rowIndex: n, colIndex: i }
    };
  },
  handlePointerMove: (e, t) => {
    const r = t.getCellByIndexes(t.pointerStartIdx.rowIndex, t.pointerStartIdx.colIndex);
    return (r == null ? void 0 : r.isSelectable) === !1 ? t : { currentBehavior: t.getBehavior("CellSelection") };
  },
  handlePointerUp: function(e, t) {
    return t;
  },
  handlePointerHold: function(e, t) {
    return t;
  },
  handlePointerHoldTouch: function(e, t) {
    return t;
  },
  handleKeyDown: function(e, t) {
    return e.key === "Shift" && (Mr = !0), Pl(e, t, { moveHorizontallyOnEnter: t.moveRightOnEnter });
  },
  handleKeyUp: function(e, t) {
    return e.key === "Shift" && (Mr = !1), t;
  },
  handlePointerDownTouch: function(e, t) {
    var f;
    const { rowIndex: r, colIndex: n } = jn(e.clientX, e.clientY), i = r === 0 && t.enableColumnSelectionOnFirstRow, a = n === 0 && t.enableRowSelectionOnFirstColumn, d = t.getCellByIndexes(r, n);
    if (!d)
      return t;
    let u = t.currentBehavior;
    const I = J(t, d);
    let x = z, h = !0;
    return i ? t.selectedArea.endRowIdx === t.rows.length && (h = !de(t, d, t.selectedArea)) : a && t.selectedArea.endColIdx === t.columns.length && (h = !de(t, d, t.selectedArea)), i ? (Dr(t, "column", d) && (u = wn), u.id !== wn.id && (x = Qo(t, I))) : a && (Dr(t, "row", d) && (u = _t), u.id !== _t.id && (x = ei(t, I))), h && (i || a) ? ((d == null ? void 0 : d.isFocusable) !== !1 && ((f = oe(t.id, r, n)) == null || f.focus({ preventScroll: !0 })), {
      selectedArea: x,
      pointerStartIdx: { rowIndex: r, colIndex: n }
    }) : po(u.id) ? {
      ...u.id === _t.id && { lineOrientation: "horizontal" },
      currentBehavior: u,
      pointerStartIdx: { rowIndex: r, colIndex: n }
    } : { pointerStartIdx: { rowIndex: r, colIndex: n } };
  },
  handlePointerMoveTouch: function(e, t) {
    const r = t.pointerStartIdx.rowIndex === 0 && t.enableColumnSelectionOnFirstRow, n = t.pointerStartIdx.colIndex === 0 && t.enableRowSelectionOnFirstColumn;
    if (r || n)
      return { ...t, currentBehavior: t.getBehavior("CellSelection") };
    const i = t.getCellByIndexes(t.pointerStartIdx.rowIndex, t.pointerStartIdx.colIndex);
    return t.pointerStartIdx.rowIndex !== t.focusedLocation.rowIndex || t.pointerStartIdx.colIndex !== t.focusedLocation.colIndex || (i == null ? void 0 : i.isSelectable) === !1 ? t : { ...t, currentBehavior: t.getBehavior("CellSelection") };
  },
  handlePointerUpTouch: function(e, t) {
    var x;
    const r = Et(e.clientX, e.clientY);
    if (!r)
      return t;
    const { rowIndex: n, colIndex: i } = Dn(r), a = t.getCellByIndexes(n, i), d = Rn(r, !0) ?? t.reactGridRef;
    Gn(t, n, i, d);
    const u = ti(t, t.pointerStartIdx), I = ti(t, { rowIndex: n, colIndex: i });
    if (u && I) {
      const h = Dn(u), f = Dn(I), C = i === 0 && t.enableRowSelectionOnFirstColumn, m = f.rowIndex === 0 && t.enableColumnSelectionOnFirstRow;
      if (h.rowIndex === f.rowIndex && h.colIndex === f.colIndex && (!m && (a == null ? void 0 : a.isFocusable) !== !1 && ((x = oe(t.id, n, i)) == null || x.focus({ preventScroll: !0 })), !m && !C))
        return { selectedArea: z };
    }
    return t;
  },
  handleCopy: function(e, t) {
    var i;
    e.preventDefault();
    const r = t.getCellByIndexes(t.focusedLocation.rowIndex, t.focusedLocation.colIndex);
    if (!r)
      return t;
    let n;
    return ue(t.selectedArea, z) ? n = J(t, r) : n = t.selectedArea, t.onCopy && ((i = t.onCopy) != null && i.call(t, e, n, t.cellsLookup)) || ni(e, t, n), t;
  },
  handleCut: function(e, t) {
    var i;
    e.preventDefault();
    const r = t.getCellByIndexes(t.focusedLocation.rowIndex, t.focusedLocation.colIndex);
    if (!r)
      return t;
    let n;
    return ue(t.selectedArea, z) ? n = J(t, r) : n = t.selectedArea, t.onCut && ((i = t.onCut) != null && i.call(t, e, n, t.cellsLookup)) || ri(e, t, n), t;
  },
  handlePaste: function(e, t) {
    var i;
    e.preventDefault();
    const r = t.getCellByIndexes(t.focusedLocation.rowIndex, t.focusedLocation.colIndex);
    if (!r)
      return t;
    let n;
    if (ue(t.selectedArea, z) ? n = J(t, r) : n = t.selectedArea, t.onPaste) {
      if (!((i = t.onPaste) == null ? void 0 : i.call(t, e, n, t.cellsLookup)))
        return oi(e, t, n);
    } else
      return oi(e, t, n);
    return t;
  }
}), ni = (e, t, r) => {
  const { startRowIdx: n, endRowIdx: i, startColIdx: a, endColIdx: d } = r, u = [];
  for (let h = n; h < i; h++)
    for (let f = a; f < d; f++) {
      const C = t.cellsLookup.get(`${h} ${f}`);
      C && u.push(C);
    }
  const I = u.filter((h) => h && Object.keys(h).length > 0).map((h) => h.onStringValueRequested()), x = `
  <table>
    ${Array.from(
    { length: r.endRowIdx - r.startRowIdx },
    (h, f) => `
      <tr>
        ${Array.from({ length: r.endColIdx - r.startColIdx }, (C, m) => {
      var R;
      const S = t.cellsLookup.get(
        `${r.startRowIdx + f} ${r.startColIdx + m}`
      );
      return `<td>${((R = S == null ? void 0 : S.onStringValueRequested) == null ? void 0 : R.call(S)) || ""}</td>`;
    }).join("")}
      </tr>
    `
  ).join("")}
  </table>
`;
  e.clipboardData.setData("text/html", x), e.clipboardData.setData("text/plain", I.join("	"));
}, ri = (e, t, r) => {
  const { startRowIdx: n, endRowIdx: i, startColIdx: a, endColIdx: d } = r, u = [];
  for (let h = n; h < i; h++)
    for (let f = a; f < d; f++) {
      const C = t.cellsLookup.get(`${h} ${f}`);
      C && u.push(C);
    }
  const I = u.filter((h) => h && Object.keys(h).length > 0).map((h) => h.onStringValueRequested());
  u.forEach((h) => {
    var f;
    return h && ((f = h.onStringValueReceived) == null ? void 0 : f.call(h, ""));
  });
  const x = `
  <table>
    ${Array.from(
    { length: r.endRowIdx - r.startRowIdx },
    (h, f) => `
      <tr>
        ${Array.from({ length: r.endColIdx - r.startColIdx }, (C, m) => {
      var R;
      const S = t.cellsLookup.get(
        `${r.startRowIdx + f} ${r.startColIdx + m}`
      );
      return `<td>${((R = S == null ? void 0 : S.onStringValueRequested) == null ? void 0 : R.call(S)) || ""}</td>`;
    }).join("")}
      </tr>
    `
  ).join("")}
  </table>
`;
  e.clipboardData.setData("text/html", x), e.clipboardData.setData("text/plain", I.join("	"));
}, oi = (e, t, r) => {
  const n = e.clipboardData.getData("text/html"), d = new DOMParser().parseFromString(n, "text/html").querySelectorAll("tr");
  if (d.length === 0)
    return t;
  const u = d[0].querySelectorAll("td");
  if (d.length === 1 && u.length === 1) {
    const x = u[0].textContent || "";
    for (let h = r.startRowIdx; h < r.endRowIdx; h++)
      for (let f = r.startColIdx; f < r.endColIdx; f++) {
        const C = t.cellsLookup.get(`${h} ${f}`);
        C == null || C.onStringValueReceived(x);
      }
  } else
    d.forEach((x, h) => {
      x.querySelectorAll("td").forEach((C, m) => {
        var R;
        const S = C.textContent || "", p = t.cellsLookup.get(
          `${r.startRowIdx + h} ${r.startColIdx + m}`
        );
        p && ((R = p.onStringValueReceived) == null || R.call(p, S));
      });
    });
  let I;
  if (d.length === 1 && u.length === 1)
    I = {
      startRowIdx: r.startRowIdx,
      endRowIdx: r.endRowIdx,
      startColIdx: r.startColIdx,
      endColIdx: r.endColIdx
    };
  else {
    const x = Math.min(r.startRowIdx + d.length, t.rows.length), h = Math.min(r.startColIdx + d[0].querySelectorAll("td").length, t.columns.length);
    I = {
      startRowIdx: r.startRowIdx,
      endRowIdx: x,
      startColIdx: r.startColIdx,
      endColIdx: h
    };
  }
  return { ...t, selectedArea: I };
}, Ml = (e, t, r) => {
  var i, a;
  const n = Et(t, r);
  if (n) {
    const { rowIndex: d, colIndex: u } = Dn(n), I = e.getCellByIndexes(d, u);
    if (!I)
      return -1;
    const x = le(e, I);
    if (!x)
      return -1;
    if (I && I.colSpan) {
      const h = t - ((i = x == null ? void 0 : x.getBoundingClientRect) == null ? void 0 : i.call(x).left), f = ((a = x.getBoundingClientRect) == null ? void 0 : a.call(x).width) / I.colSpan, C = Math.floor(h / f);
      return u + C;
    }
    return u;
  }
  return -1;
}, Fl = (e, t, r) => {
  var i, a;
  const n = Et(t, r);
  if (n) {
    const { rowIndex: d, colIndex: u } = Dn(n), I = e.getCellByIndexes(d, u);
    if (!I)
      return -1;
    const x = le(e, I);
    if (!x)
      return -1;
    if (I && I.rowSpan) {
      const h = r - ((i = x == null ? void 0 : x.getBoundingClientRect) == null ? void 0 : i.call(x).top), f = ((a = x.getBoundingClientRect) == null ? void 0 : a.call(x).height) / I.rowSpan, C = Math.floor(h / f);
      return d + C;
    }
    return d;
  }
  return -1;
}, Hl = (e, t) => {
  const r = Fl(e, t.clientX, t.clientY), n = Ml(e, t.clientX, t.clientY), i = e.getCellByIndexes(e.focusedLocation.rowIndex, e.focusedLocation.colIndex);
  if (r === -1 || n === -1)
    return;
  const a = e.selectedArea, d = e.selectedArea.startRowIdx !== -1;
  let u;
  d ? u = a : i ? u = J(e, i) : u = z;
  const I = r >= u.endRowIdx ? Math.abs(r + 1 - u.endRowIdx) : 0, x = r <= u.startRowIdx ? Math.abs(r - u.startRowIdx) : 0, h = n >= u.endColIdx ? Math.abs(n + 1 - u.endColIdx) : 0, f = n <= u.startColIdx ? Math.abs(n - u.startColIdx) : 0;
  if (r >= u.endRowIdx && I >= h && I >= f)
    return {
      direction: "down",
      value: r
    };
  if (r <= u.startRowIdx && x >= h && x >= f)
    return {
      direction: "up",
      value: r
    };
  if (n >= u.endColIdx && h > x && h > I)
    return {
      direction: "right",
      value: n
    };
  if (n <= u.startColIdx && f > x && f > I)
    return {
      direction: "left",
      value: n
    };
};
function zl(e) {
  const { fillHandleArea: t, selectedArea: r, getFocusedCell: n } = e, i = n(), a = i ? J(e, i) : z, d = Ce(r, z) ? a : r;
  return t.startRowIdx === d.endRowIdx ? "bottom" : t.endRowIdx === d.startRowIdx ? "top" : t.startColIdx === d.endColIdx ? "right" : t.endColIdx === d.startColIdx ? "left" : "";
}
qt();
const wo = {
  id: "FillHandle",
  handlePointerDown: function(e, t) {
    return t;
  },
  handlePointerMove: function(e, t) {
    return ii(t, e);
  },
  handlePointerUp: function(e, t) {
    return ai(t);
  },
  handlePointerDownTouch: function(e, t) {
    return t;
  },
  handlePointerMoveTouch: function(e, t) {
    return ii(t, e);
  },
  handlePointerUpTouch: function(e, t) {
    return ai(t);
  }
}, ii = (e, t) => {
  const { clientX: r, clientY: n } = t, i = jn(r, n), a = e.getCellByIndexes(i.rowIndex, i.colIndex);
  let d;
  Ce(e.selectedArea, z) ? d = $n(e, e.getFocusedCell()) : d = $n(
    e,
    e.getCellByIndexes(e.selectedArea.endRowIdx - 1, e.selectedArea.endColIdx - 1)
  ), a && (d === "Center" && rt(e, a, i), (d === "Left" || d === "Right") && rt(e, a, i, !1, !0), (d === "TopCenter" || d === "BottomCenter") && rt(e, a, i, !0));
  const u = Hl(e, t), I = e.getCellByIndexes(e.focusedLocation.rowIndex, e.focusedLocation.colIndex), x = e.selectedArea, h = e.selectedArea.startRowIdx !== -1, f = I ? J(e, I) : z;
  if (!u || u.value === null)
    return {
      fillHandleArea: z
    };
  switch (u == null ? void 0 : u.direction) {
    case "up":
      return {
        fillHandleArea: {
          startColIdx: h ? x.startColIdx : f.startColIdx,
          startRowIdx: u.value,
          endColIdx: h ? x.endColIdx : f.endColIdx,
          endRowIdx: h ? x.startRowIdx : f.startRowIdx
        }
      };
    case "right":
      return {
        fillHandleArea: {
          startColIdx: h ? x.endColIdx : f.endColIdx,
          startRowIdx: h ? x.startRowIdx : f.startRowIdx,
          endColIdx: u.value + 1,
          endRowIdx: h ? x.endRowIdx : f.endRowIdx
        }
      };
    case "down":
      return {
        fillHandleArea: {
          startColIdx: h ? x.startColIdx : f.startColIdx,
          startRowIdx: h ? x.endRowIdx : f.endRowIdx,
          endColIdx: h ? x.endColIdx : f.endColIdx,
          endRowIdx: u.value + 1
        }
      };
    case "left":
      return {
        fillHandleArea: {
          startColIdx: u.value,
          startRowIdx: h ? x.startRowIdx : f.startRowIdx,
          endColIdx: h ? x.startColIdx : f.startColIdx,
          endRowIdx: h ? x.endRowIdx : f.endRowIdx
        }
      };
  }
  return e;
}, ai = (e) => {
  const t = zl(e), r = e.getCellByIndexes(e.focusedLocation.rowIndex, e.focusedLocation.colIndex), n = e.selectedArea, i = e.cellsLookup;
  if (e.fillHandleArea.startRowIdx !== -1) {
    let u;
    e.selectedArea.startRowIdx !== -1 ? u = e.selectedArea : u = r ? J(e, r) : z, e.onFillHandle && e.onFillHandle(u, e.fillHandleArea, i) || li(u, e.fillHandleArea, i);
  }
  const a = n.startRowIdx !== -1, d = e.fillHandleArea;
  return Ce(d, z) ? {
    ...e,
    fillHandleArea: z,
    currentBehavior: e.getBehavior("Default")
  } : (t === "bottom" ? a ? d.startRowIdx = e.selectedArea.startRowIdx : d.startRowIdx = d.startRowIdx - (((r == null ? void 0 : r.rowSpan) ?? 1) || 1) : t === "top" ? a ? d.endRowIdx = e.selectedArea.endRowIdx : d.endRowIdx = d.endRowIdx + (((r == null ? void 0 : r.rowSpan) ?? 1) || 1) : t === "right" ? a ? d.startColIdx = e.selectedArea.startColIdx : d.startColIdx = d.startColIdx - (((r == null ? void 0 : r.colSpan) ?? 1) || 1) : t === "left" && (a ? d.endColIdx = e.selectedArea.endColIdx : d.endColIdx = d.endColIdx + (((r == null ? void 0 : r.colSpan) ?? 1) || 1)), {
    ...e,
    selectedArea: d,
    fillHandleArea: z,
    currentBehavior: e.getBehavior("Default")
  });
}, li = (e, t, r) => {
  const n = t.startRowIdx < e.startRowIdx, i = e.endRowIdx - e.startRowIdx, a = e.endColIdx - e.startColIdx;
  for (let d = t.startRowIdx; d < t.endRowIdx; d++)
    for (let u = t.startColIdx; u < t.endColIdx; u++) {
      const I = r.get(`${d} ${u}`);
      if (!I || d === 0)
        continue;
      const x = n ? (e.endRowIdx - d - 1) % i : (d - t.startRowIdx) % i, h = (u - t.startColIdx) % a, f = r.get(
        `${e.startRowIdx + x} ${e.startColIdx + h}`
      ), C = (m) => !!m && Object.keys(m).length > 0;
      if (C(f) && C(I)) {
        const m = f.onStringValueRequested();
        I.onStringValueReceived(m);
      }
    }
};
qt();
let Tr = 0, Co = 0, Ro = 0;
const ki = {
  id: "ResizeColumn",
  handlePointerDown: function(e, t) {
    return di(e, t);
  },
  handlePointerMove: (e, t) => si(e, t),
  handlePointerUp: function(e, t) {
    return ci(e, t);
  },
  handlePointerHold: function(e, t) {
    return t;
  },
  handlePointerHoldTouch: function(e, t) {
    return t;
  },
  handlePointerDownTouch: function(e, t) {
    return di(e, t);
  },
  handlePointerMoveTouch: function(e, t) {
    return si(e, t);
  },
  handlePointerUpTouch: function(e, t) {
    return ci(e, t);
  }
}, di = (e, t) => {
  const n = e.target.parentNode, i = n.offsetWidth;
  return Tr = n.offsetLeft, Ro = i, Co = e.clientX, {
    ...t,
    lineOrientation: "vertical",
    linePosition: n.offsetLeft + n.offsetWidth
  };
}, si = (e, t) => {
  const r = t.reactGridRef;
  if (!r)
    return t;
  const i = r.getBoundingClientRect().left, a = e.clientX - i, d = t.getCellByIndexes(0, t.resizingColIdx ?? 0), I = (d.colSpan ? Array.from({ length: d.colSpan }, (x, h) => h + d.colIndex) : [d.colIndex]).reduce((x, h) => {
    const f = t.getColumnByIdx(h);
    return x + Nn((f == null ? void 0 : f.minWidth) ?? 0);
  }, 0);
  return {
    ...t,
    linePosition: a > Tr + I ? a : Tr + I
  };
}, ci = (e, t) => {
  var C, m;
  const r = e.clientX - Co;
  if (t.resizingColIdx === void 0)
    return t;
  const n = Ro + r, i = t.reactGridRef;
  if (!i)
    return t;
  const a = t.getColumnByIdx(t.resizingColIdx), d = Nn((a == null ? void 0 : a.minWidth) ?? 0), I = i.getBoundingClientRect().left, x = e.clientX - I, h = t.getCellByIndexes(0, t.resizingColIdx), f = h.colSpan ? Array.from({ length: h.colSpan }, (S, p) => p + h.colIndex) : [h.colIndex];
  return x <= Tr + d ? (C = t.onResizeColumn) == null || C.call(t, d, f) : (m = t.onResizeColumn) == null || m.call(t, n, f), Tr = 0, Co = 0, Ro = 0, {
    ...t,
    linePosition: void 0,
    currentBehavior: t.getBehavior("Default"),
    resizingColIdx: void 0
  };
}, Xt = gl(() => ({})), ui = {
  id: "",
  // fields passed by the user
  rows: [],
  columns: [],
  cells: /* @__PURE__ */ new Map(),
  cellsLookup: /* @__PURE__ */ new Map(),
  paneRanges: {
    TopLeft: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    TopCenter: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    TopRight: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    Left: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    Center: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    Right: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    BottomLeft: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    BottomCenter: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 },
    BottomRight: { startRowIdx: 0, endRowIdx: 0, startColIdx: 0, endColIdx: 0 }
  },
  behaviors: {
    Default: go(),
    CellSelection: Hi,
    ColumnReorder: wn,
    RowReorder: _t,
    ResizeColumn: ki,
    FillHandle: wo
  },
  styledRanges: [],
  onFillHandle: void 0,
  onAreaSelected: void 0,
  onCellFocused: void 0,
  onCut: void 0,
  onPaste: void 0,
  moveRightOnEnter: !1,
  // internal state
  rowMeasurements: [],
  colMeasurements: [],
  focusedLocation: { rowIndex: -1, colIndex: -1 },
  changedFocusedLocation: void 0,
  // used from reorder behaviors
  selectedArea: { startRowIdx: -1, endRowIdx: -1, startColIdx: -1, endColIdx: -1 },
  fillHandleArea: { startRowIdx: -1, endRowIdx: -1, startColIdx: -1, endColIdx: -1 },
  reactGridRef: void 0,
  resizingColIdx: void 0,
  lineOrientation: "vertical",
  linePosition: void 0,
  shadowPosition: void 0,
  shadowSize: void 0,
  pointerStartIdx: { rowIndex: -1, colIndex: -1 },
  // used for cell selection behavior
  currentBehavior: go()
};
function jl(e, t) {
  Xt.setState((r) => r[e] ? r : {
    ...r,
    [e]: Mi()((n, i) => ({
      ...ui,
      ...t,
      id: e,
      behaviors: { ...ui.behaviors, ...t == null ? void 0 : t.behaviors },
      getRowAmount: () => i().rows.length,
      getColumnByIdx: (a) => i().columns[a],
      setExternalData: (a) => n(() => ({ ...a, behaviors: { ...i().behaviors, ...a.behaviors } })),
      setCellsLookup: (a) => n(() => ({ cellsLookup: a })),
      getCellsLookup: () => i().cellsLookup,
      getColumnAmount: () => i().columns.length,
      getColumnCells: (a) => {
        const { cells: d } = i();
        return Array.from(d.values()).flat().filter((u) => Be(u) ? u.originColIndex === a : u.colIndex === a);
      },
      setStyles: (a) => n(() => ({ styles: a })),
      getCellByIndexes: (a, d) => {
        const { cells: u } = i();
        if (a === -1 || d === -1)
          return null;
        const I = u.get(`${a} ${d}`);
        return I ? Be(I) ? u.get(`${I.originRowIndex} ${I.originColIndex}`) : I : null;
      },
      getCellOrSpanMemberByIndexes: (a, d) => {
        const { rows: u, columns: I, cells: x } = i(), h = u[a], f = I[d];
        if (!h || !f)
          return null;
        const C = x.get(`${a} ${d}`);
        return C || null;
      },
      setRowMeasurements: (a) => n(() => ({ rowMeasurements: a })),
      setColMeasurements: (a) => n(() => ({ colMeasurements: a })),
      setPaneRanges: (a) => n(() => ({ paneRanges: a })),
      getPaneRanges: () => {
        const { paneRanges: a } = i();
        return a;
      },
      setFocusedLocation: (a, d) => {
        var u;
        (u = oe(e, a, d)) == null || u.focus(), n(() => ({ focusedLocation: { rowIndex: a, colIndex: d } }));
      },
      getFocusedCell: () => {
        const { focusedLocation: a } = i(), d = i().getCellByIndexes(a.rowIndex, a.colIndex);
        return d ? { ...d, ...a } : null;
      },
      getSelectedArea: () => {
        const { selectedArea: a } = i();
        return a;
      },
      setSelectedArea: (a) => n(() => ({ selectedArea: a })),
      setSelectedColumns: (a, d) => {
        const { setSelectedArea: u } = i();
        u({ startRowIdx: 0, endRowIdx: i().getRowAmount(), startColIdx: a, endColIdx: d });
      },
      setSelectedRows: (a, d) => {
        const { setSelectedArea: u } = i();
        u({ startRowIdx: a, endRowIdx: d, startColIdx: 0, endColIdx: i().getColumnAmount() });
      },
      setFillHandleArea: (a) => n(() => ({ fillHandleArea: a })),
      setCurrentBehavior: (a) => n(() => ({ currentBehavior: a })),
      setResizingColIdx: (a) => n(() => ({ resizingColIdx: a })),
      setLineOrientation: (a) => n(() => ({ lineOrientation: a })),
      setLinePosition: (a) => n(() => ({ linePosition: a })),
      assignReactGridRef: (a) => n(() => ({ reactGridRef: a })),
      getBehavior: (a) => {
        var u;
        const d = (u = i().behaviors) == null ? void 0 : u[a];
        if (!d)
          throw new Error(`Behavior with id "${a}" doesn't exist!`);
        return d;
      },
      getStyledRanges: (a) => {
        const d = i().styledRanges;
        if (a) {
          const u = d.find((I) => {
            JSON.stringify(I.range), JSON.stringify(a);
          });
          return u ? [u] : [];
        } else
          return d || [];
      }
    }))
  });
}
function U(e, t) {
  const r = Xt()[e];
  if ((r == null ? void 0 : r.getState()) === void 0)
    throw new Error(`ReactGridStore with id "${e}" doesn't exist!`);
  return bo(r, t);
}
const Nl = (e, t) => {
  const r = bo(Xt, (i) => i[e]), n = r == null ? void 0 : r.getState();
  if (n)
    return t(n);
}, Gl = [
  ["focuschange", "focusedLocation"],
  ["selectionchange", "selectedArea"]
], Ul = ["focusedLocation", "selectedArea"], Ki = (e, t, r) => {
  const n = e.getState();
  if (r) {
    const i = r(t, n), a = kl(n, i, Ul);
    return Ce(n, i) ? void 0 : (Vl(a), e.setState(i), i);
  }
};
function Wl(e) {
  const t = Gl.find(([r, n]) => n === e);
  if (t) {
    const [r, n] = t;
    return r;
  } else
    return null;
}
function kl(e, t, r) {
  const n = {};
  return r.forEach((i) => {
    const a = e[i], d = t[i];
    d !== void 0 && Kl(a, d) && (n[i] = { after: d, before: a });
  }), n;
}
function Kl(e, t) {
  return JSON.stringify(e) !== JSON.stringify(t);
}
function Vl(e) {
  Object.entries(e).forEach(([t, r]) => {
    const n = Wl(t);
    if (n)
      Wn(n, { [t]: r });
    else
      return;
  });
}
const Yl = (e, t) => {
  const r = e.pointerType !== "mouse";
  let n;
  (e.button === 2 || r) && (n = setTimeout(() => {
    const m = r ? a().currentBehavior.handlePointerHoldTouch : a().currentBehavior.handlePointerHold;
    d(e, m);
  }, 500));
  function a() {
    return t.getState();
  }
  const d = (m, S) => Ki(t, m, S), u = t.getState();
  let I = null;
  const x = (m) => {
    const S = r ? a().currentBehavior.handlePointerMoveTouch : a().currentBehavior.handlePointerMove;
    d(m, S);
    const p = Et(m.clientX, m.clientY);
    p && (I && !zi(p, I) && h(m), I = p);
  }, h = (m) => {
    const S = r ? a().currentBehavior.handlePointerEnterTouch : a().currentBehavior.handlePointerEnter;
    d(m, S);
  }, f = (m) => {
    window.removeEventListener("pointermove", x), window.removeEventListener("pointerup", f), n && clearTimeout(n);
    const S = r ? a().currentBehavior.handlePointerUpTouch : a().currentBehavior.handlePointerUp;
    d(m, S);
  };
  window.addEventListener("pointermove", x), window.addEventListener("pointerup", f);
  const C = r ? u.currentBehavior.handlePointerDownTouch : u.currentBehavior.handlePointerDown;
  d(e, C);
}, ql = ({ reactGridId: e, style: t, children: r }) => {
  const n = Xt()[e], i = U(e, (f) => f.currentBehavior), a = qe(null), d = U(e, (f) => f.assignReactGridRef), u = U(e, (f) => f.styledRanges), [I, x] = Kt(Di({}));
  Te(() => {
    a.current && d(a.current);
  }, [a]);
  const h = (f, C) => Ki(n, f, C);
  return Te(() => {
    const f = ll(n.getState(), u);
    f && x(f);
  }, [u.length]), /* @__PURE__ */ N(
    "div",
    {
      css: I,
      id: `ReactGrid-${e}`,
      className: "ReactGrid",
      ref: a,
      style: t,
      onPointerDown: (f) => {
        f.preventDefault(), Yl(f, n);
      },
      onFocus: (f) => h(f, i == null ? void 0 : i.handleFocus),
      onKeyDown: (f) => h(f, i == null ? void 0 : i.handleKeyDown),
      onKeyUp: (f) => h(f, i == null ? void 0 : i.handleKeyUp),
      onCompositionStart: (f) => h(f, i == null ? void 0 : i.handleCompositionStart),
      onCompositionUpdate: (f) => h(f, i == null ? void 0 : i.handleCompositionUpdate),
      onCompositionEnd: (f) => h(f, i == null ? void 0 : i.handleCompositionEnd),
      onCut: (f) => h(f, i == null ? void 0 : i.handleCut),
      onCopy: (f) => h(f, i == null ? void 0 : i.handleCopy),
      onPaste: (f) => h(f, i == null ? void 0 : i.handlePaste),
      onContextMenu: (f) => h(f, i == null ? void 0 : i.handleContextMenu),
      children: r
    }
  );
}, Vi = gi(""), Xl = ({ id: e, children: t }) => /* @__PURE__ */ N(Vi.Provider, { value: e, children: t }), It = () => Yt.useContext(Vi), mn = () => {
  const e = It(), t = U(e, (n) => n.styles), r = Ao(Ni);
  return ji(r, tl(), t);
}, Yi = (e, t) => {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && typeof t == "function")
    return e.toString() === t.toString();
  if (e === null || t === null || typeof e != "object" || typeof t != "object")
    return !1;
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const i of r)
    if (!Yi(e[i], t[i]))
      return !1;
  return !0;
}, qi = gi({
  realRowIndex: -1,
  realColumnIndex: -1,
  isSelected: !1,
  isFocused: !1,
  containerStyle: {}
}), Qr = () => {
  const e = pi(qi);
  if (!e)
    throw new Error("CellContext is unavailable! Did you use this hook outside of ReactGrid's PaneGridRenderer?");
  return e;
}, Jl = ta(
  ({
    rowIndex: e,
    colIndex: t,
    realRowIndex: r,
    realColumnIndex: n,
    rowSpan: i,
    colSpan: a,
    getCellOffset: d = () => ({}),
    cell: u,
    isSelected: I,
    isFocused: x
  }) => {
    const { Template: h, props: f } = u;
    return /* @__PURE__ */ N(
      qi.Provider,
      {
        value: {
          realRowIndex: r,
          realColumnIndex: n,
          isSelected: I,
          isFocused: x,
          containerStyle: {
            ...i && {
              gridRowEnd: `span ${i}`
            },
            ...a && {
              gridColumnEnd: `span ${a}`
            },
            ...d == null ? void 0 : d(e, t, i ?? 1, a ?? 1),
            gridRowStart: r + 1,
            gridColumnStart: n + 1
          }
        },
        children: /* @__PURE__ */ N(h, { ...f })
      }
    );
  },
  (e, t) => !t.shouldRenderReorderedCells && Yi(e.cell, t.cell) && e.isSelected === t.isSelected && e.isFocused === t.isFocused && e.getCellOffset === t.getCellOffset
), Zl = (e, t) => {
  const {
    startRowIdx: r,
    endRowIdx: n,
    startColIdx: i,
    endColIdx: a
  } = e.areaRange, {
    startRowIdx: d,
    endRowIdx: u,
    startColIdx: I,
    endColIdx: x
  } = t.areaRange;
  return !(r !== d || n !== u || i !== I || a !== x || e.getCellOffset !== t.getCellOffset);
}, lo = Yt.memo(
  ({
    areaRange: e,
    parentPaneName: t,
    parentPaneRange: r,
    getCellOffset: n,
    isFocusedCellPartial: i = !1,
    isFillHandlePartial: a = !1,
    border: d,
    style: u,
    className: I
  }) => {
    const x = mn(), h = {}, f = d ?? x.area.border, C = It(), m = Xt()[C].getState(), S = U(C, (M) => M.currentBehavior), p = U(C, (M) => M.setCurrentBehavior), R = U(C, (M) => M.selectedArea), v = U(C, (M) => M.paneRanges), y = U(C, (M) => M.fillHandleArea), _ = U(C, (M) => M.disableFillHandle), A = m.getCellByIndexes(m.focusedLocation.rowIndex, m.focusedLocation.colIndex) ?? void 0, w = A ? J(m, A) : z, E = U(C, (M) => M.focusedLocation);
    if (e.startRowIdx < 0 || e.startColIdx < 0 || e.endRowIdx < 0 || e.endColIdx < 0)
      return null;
    if (e.startRowIdx > e.endRowIdx)
      throw new Error("Invalid range! Start row index is greater than end row index!");
    if (e.startColIdx > e.endColIdx)
      throw new Error("Invalid range! Start column index is greater than end column index!");
    if (e.startColIdx >= r.endColIdx || e.startRowIdx >= r.endRowIdx || e.endColIdx <= r.startColIdx || e.endRowIdx <= r.startRowIdx)
      return null;
    let L = !1;
    e.startRowIdx >= r.startRowIdx && (a ? (R.startRowIdx > w.endRowIdx && !Ce(R, z) && !de(m, A, R) && y.startRowIdx < R.startRowIdx || y.startRowIdx !== w.endRowIdx && y.startRowIdx !== R.endRowIdx) && (L = !0) : L = !0);
    let j = !1;
    e.endColIdx <= r.endColIdx && (a ? (R.startColIdx < w.endColIdx && !Ce(R, z) && !de(m, A, R) && y.endColIdx > R.endColIdx || y.endColIdx !== w.startColIdx && y.endColIdx !== R.startColIdx) && (j = !0) : j = !0);
    let F = !1;
    e.endRowIdx <= r.endRowIdx && (a ? (R.startRowIdx < w.endRowIdx && !Ce(R, z) && !de(m, A, R) && y.endRowIdx > R.endRowIdx || y.endRowIdx !== w.startRowIdx && y.endRowIdx !== R.startRowIdx) && (F = !0) : F = !0);
    let W = !1;
    e.startColIdx >= r.startColIdx && (a ? (R.startColIdx > w.endColIdx && !Ce(R, z) && !de(m, A, R) && y.startColIdx < R.startColIdx || y.startColIdx !== w.endColIdx && y.startColIdx !== R.endColIdx) && (W = !0) : W = !0);
    let Y = "100%", T = "100%";
    const B = {
      gridRowStart: e.startRowIdx < r.startRowIdx ? r.startRowIdx + 1 : e.startRowIdx + 1,
      gridRowEnd: e.endRowIdx > r.endRowIdx ? r.endRowIdx + 1 : e.endRowIdx + 1,
      gridColumnStart: e.startColIdx < r.startColIdx ? r.startColIdx + 1 : e.startColIdx + 1,
      gridColumnEnd: e.endColIdx > r.endColIdx ? r.endColIdx + 1 : e.endColIdx + 1
    };
    (t === "TopLeft" || t === "TopCenter" || t === "TopRight") && (B.position = "sticky", h.top = n == null ? void 0 : n(e.startRowIdx, e.startColIdx, 1, 1).top, F || (T = `calc(100% - (${f.width} - ${x.gap.width}))`)), (t === "TopRight" || t === "Right" || t === "BottomRight") && (B.position = "sticky", h.right = n == null ? void 0 : n(
      e.startRowIdx,
      e.endColIdx - r.startColIdx - 1,
      1,
      1
    ).right, W || (Y = `calc(100% - (${f.width} - ${x.gap.width}))`)), (t === "BottomLeft" || t === "BottomCenter" || t === "BottomRight") && (B.position = "sticky", h.bottom = n == null ? void 0 : n(
      e.endRowIdx - r.startRowIdx - 1,
      e.startColIdx,
      1,
      1
    ).bottom, L || (T = `calc(100% - (${f.width} - ${x.gap.width}))`)), (t === "TopLeft" || t === "Left" || t === "BottomLeft") && (B.position = "sticky", h.left = n == null ? void 0 : n(e.startRowIdx, e.startColIdx, 1, 1).left, j || (Y = `calc(100% - (${f.width} - ${x.gap.width}))`));
    let H = !1;
    if (!_) {
      const M = ["TopLeft", "TopCenter", "TopRight"].includes(t), V = ["Left", "Center", "Right"].includes(t), Q = M && R.endRowIdx > v.TopCenter.endRowIdx || V && R.endRowIdx > v.Center.endRowIdx, be = t === "TopLeft" && R.endColIdx > v.TopLeft.endColIdx || t === "TopCenter" && R.endColIdx > v.TopCenter.endColIdx || t === "Left" && R.endColIdx > v.Left.endColIdx || t === "Center" && R.endColIdx > v.Center.endColIdx || t === "BottomLeft" && R.endColIdx > v.BottomLeft.endColIdx || t === "BottomCenter" && R.endColIdx > v.BottomCenter.endColIdx;
      Ce(R, z) ? i && (H = !0) : (i && ue(R, w) || !i && !a) && (Q || be || (H = !0));
    }
    return /* @__PURE__ */ N(vo, { children: /* @__PURE__ */ Vt(
      "div",
      {
        className: `rgPartialArea ${I ?? ""}`,
        style: {
          ...u,
          width: Y,
          height: T,
          boxSizing: "border-box",
          position: "sticky",
          pointerEvents: "none",
          ...h,
          ...B
        },
        children: [
          /* @__PURE__ */ N(
            "div",
            {
              style: {
                position: "absolute",
                top: `-${x.gap.width}`,
                right: `-${x.gap.width}`,
                bottom: `-${x.gap.width}`,
                left: `-${x.gap.width}`,
                ...L && {
                  borderTop: `${f.width} ${f.style} ${f.color}`
                },
                ...j && {
                  borderRight: `${f.width} ${f.style} ${f.color}`
                },
                ...F && {
                  borderBottom: `${f.width} ${f.style} ${f.color}`
                },
                ...W && {
                  borderLeft: `${f.width} ${f.style} ${f.color}`
                }
              }
            }
          ),
          S.id !== Hi.id && H && /* @__PURE__ */ N(
            "div",
            {
              className: "rg-touch-fill-handle",
              style: {
                position: "absolute",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                right: `calc(-${x.gap.width} - 15px)`,
                bottom: `calc(-${x.gap.width} - 15px)`,
                width: 30,
                height: 30,
                pointerEvents: "auto",
                touchAction: "none"
              },
              onPointerDown: (M) => {
                M.pointerType !== "mouse" && p(wo);
              },
              children: /* @__PURE__ */ N(
                "div",
                {
                  className: "rg-fill-handle",
                  style: {
                    width: 6.5,
                    height: 6.5,
                    backgroundColor: a ? f.color : x.focusIndicator.border.color,
                    cursor: "crosshair",
                    boxSizing: "content-box",
                    pointerEvents: "auto",
                    border: "2px solid #fff",
                    borderRadius: "50%"
                  },
                  onPointerDown: () => {
                    var M;
                    (M = oe(C, E.rowIndex, E.colIndex)) == null || M.focus(), p(wo);
                  }
                }
              )
            }
          )
        ]
      }
    ) });
  },
  Zl
), Ql = (e, t) => {
  const {
    startRowIdx: r,
    endRowIdx: n,
    startColIdx: i,
    endColIdx: a
  } = e.range, {
    startRowIdx: d,
    endRowIdx: u,
    startColIdx: I,
    endColIdx: x
  } = t.range;
  return !(r !== d || n !== u || i !== I || a !== x || e.getCellOffset !== t.getCellOffset);
}, ed = Yt.memo(
  ({ range: e, getCellOffset: t = () => ({}), stickyOffsets: r }) => {
    const { startRowIdx: n, endRowIdx: i, startColIdx: a, endColIdx: d } = e, u = It(), I = Xt()[u].getState(), x = U(u, (y) => y.rows).slice(n, i), h = U(u, (y) => y.columns).slice(a, d), f = U(u, (y) => y.cells), C = U(u, (y) => y.focusedLocation), m = U(u, (y) => y.selectedArea), S = U(u, (y) => y.currentBehavior), p = qe(S.id), R = qe(m);
    Te(() => () => {
      p.current = S.id, R.current = m;
    }, [S.id, m]);
    const v = na(t, [r]);
    return x.map((y, _) => h.map((A, w) => {
      const E = f.get(`${n + _} ${a + w}`);
      if (!E || Be(E))
        return null;
      const L = n + _, j = a + w;
      let F = !1;
      if ((p.current === _t.id || p.current === wn.id) && S.id === go().id) {
        const T = R.current, B = m;
        F = de(I, E, {
          startRowIdx: Math.min(T.startRowIdx, B.startRowIdx),
          endRowIdx: Math.max(T.endRowIdx, B.endRowIdx),
          startColIdx: Math.min(T.startColIdx, B.startColIdx),
          endColIdx: Math.max(T.endColIdx, B.endColIdx)
        });
      }
      const W = de(I, E, m), Y = C.rowIndex === L && C.colIndex === j;
      return /* @__PURE__ */ N(
        Jl,
        {
          rowIndex: _,
          colIndex: w,
          cell: E,
          rowSpan: E.rowSpan,
          colSpan: E.colSpan,
          realRowIndex: L,
          realColumnIndex: j,
          getCellOffset: v,
          shouldRenderReorderedCells: F,
          isSelected: W,
          isFocused: Y
        },
        `${L}-${j}`
      );
    }));
  },
  Ql
), td = (e, t, r) => {
  let n = {
    position: "sticky",
    gridRowStart: t.startRowIdx + 1,
    gridRowEnd: t.endRowIdx + 1,
    gridColumnStart: t.startColIdx + 1,
    gridColumnEnd: t.endColIdx + 1,
    backgroundColor: r.color
  };
  return (e === "TopLeft" || e === "TopCenter" || e === "TopRight") && (n = {
    ...n,
    top: 0,
    height: `calc(100% + 2*${r.width})`,
    marginTop: `-${r.width}`
  }), (e === "TopRight" || e === "Right" || e === "BottomRight") && (n = {
    ...n,
    right: 0,
    width: `calc(100% + 2*${r.width})`,
    marginLeft: `-${r.width}`
  }), (e === "BottomLeft" || e === "BottomCenter" || e === "BottomRight") && (n = {
    ...n,
    bottom: 0,
    height: `calc(100% + 2*${r.width})`,
    marginTop: `-${r.width}`
  }), (e === "TopLeft" || e === "Left" || e === "BottomLeft") && (n = {
    ...n,
    left: 0,
    width: `calc(100% + 2*${r.width})`,
    marginLeft: `-${r.width}`
  }), n;
}, At = ({
  paneName: e,
  style: t,
  gridContentRange: r,
  getCellOffset: n,
  stickyOffsets: i,
  shouldRender: a = !0
}) => {
  const d = mn(), u = It(), I = U(u, (m) => m.getFocusedCell()), x = I ? {
    startRowIdx: I.rowIndex,
    endRowIdx: I.rowIndex + (I.rowSpan ?? 1),
    startColIdx: I.colIndex,
    endColIdx: I.colIndex + (I.colSpan ?? 1)
  } : z, h = U(u, (m) => m.selectedArea), f = U(u, (m) => m.fillHandleArea), C = !Ce(f, z);
  return a ? /* @__PURE__ */ Vt("div", { className: `rgPane rgPane-${e}`, style: { display: "contents", ...t }, children: [
    e !== "Center" && /* @__PURE__ */ N(
      "div",
      {
        className: `rgPaneBackground rgPaneBackground-${e}`,
        style: td(e, r, d.gap)
      }
    ),
    /* @__PURE__ */ N(ed, { range: r, getCellOffset: n, stickyOffsets: i }),
    C && /* @__PURE__ */ N(
      lo,
      {
        areaRange: f,
        parentPaneRange: r,
        parentPaneName: e,
        getCellOffset: n,
        isFillHandlePartial: !0,
        border: d.fillHandle.border,
        style: { background: d.focusIndicator.background },
        className: "rgFillHandleIndicator"
      }
    ),
    h && !ue(x, h) && /* @__PURE__ */ N(
      lo,
      {
        areaRange: {
          startRowIdx: h.startRowIdx,
          endRowIdx: h.endRowIdx,
          startColIdx: h.startColIdx,
          endColIdx: h.endColIdx
        },
        parentPaneRange: r,
        parentPaneName: e,
        getCellOffset: n,
        border: d.selectionIndicator.border,
        style: { background: d.selectionIndicator.background },
        className: "rgSelectionIndicator"
      }
    ),
    I && /* @__PURE__ */ N(
      lo,
      {
        areaRange: x,
        parentPaneRange: r,
        parentPaneName: e,
        getCellOffset: n,
        isFocusedCellPartial: !0,
        border: d.focusIndicator.border,
        style: { background: d.focusIndicator.background },
        className: "rgFocusIndicator"
      }
    )
  ] }) : null;
}, fi = (e, t, r = "forward") => {
  if (!e.length)
    return [];
  const n = e[0].offsetTop, i = [n];
  if (r === "forward")
    for (let a = 1; a < t; a++)
      i.push(e[a].offsetTop);
  else {
    const a = e.length - 1;
    for (let d = a - 1; d >= e.length - t; d--) {
      const u = i[a - d - 1] + e[d + 1].height + n;
      i.push(u + n);
    }
  }
  return i;
}, xi = (e, t, r = "forward") => {
  if (!e.length)
    return [];
  const n = e[0].offsetLeft, i = [n];
  if (r === "forward")
    for (let a = 1; a < t; a++)
      i.push(e[a].offsetLeft);
  else {
    const a = e.length - 1;
    for (let d = a - 1; d >= e.length - t; d--) {
      const u = i[a - d - 1] + e[d + 1].width + n;
      i.push(u);
    }
  }
  return i;
}, nd = (e, t, r) => {
  let n = {
    position: "sticky",
    gridRowStart: t.startRowIdx + 1,
    gridRowEnd: t.endRowIdx + 1,
    gridColumnStart: t.startColIdx + 1,
    gridColumnEnd: t.endColIdx + 1
  };
  return e === "Top" && (n = {
    ...n,
    top: 0,
    height: `calc(100% + 2*${r.width})`,
    marginTop: `-${r.width}`
  }), e === "Right" && (n = {
    ...n,
    right: 0,
    width: `calc(100% + 2*${r.width})`,
    marginLeft: `-${r.width}`
  }), e === "Bottom" && (n = {
    ...n,
    bottom: 0,
    height: `calc(100% + 2*${r.width})`,
    marginTop: `-${r.width}`
  }), e === "Left" && (n = {
    ...n,
    left: 0,
    width: `calc(100% + 2*${r.width})`,
    marginLeft: `-${r.width}`
  }), n;
}, Fr = ({
  paneShadowName: e,
  style: t,
  gridContentRange: r,
  shouldRender: n = !0
}) => {
  const i = mn();
  if (!n)
    return null;
  let a;
  return e === "Left" ? a = i.paneContainer.left.boxShadow : e === "Right" ? a = i.paneContainer.right.boxShadow : e === "Top" ? a = i.paneContainer.top.boxShadow : e === "Bottom" && (a = i.paneContainer.bottom.boxShadow), /* @__PURE__ */ N("div", { className: `rgPaneShadow rgPaneShadow-${e}`, style: { ...t, display: "contents" }, children: /* @__PURE__ */ N(
    "div",
    {
      className: `rgPaneShadowOverlay rgPaneShadowOverlay-${e}`,
      style: {
        ...nd(e, r, i.gap),
        boxShadow: a
      }
    }
  ) });
}, rd = ({
  rows: e,
  columns: t,
  cells: r,
  stickyTopRows: n,
  stickyBottomRows: i,
  stickyLeftColumns: a,
  stickyRightColumns: d
}) => {
  const u = It(), I = Xt()[u].getState(), x = mn(), h = U(u, (T) => T.focusedLocation), f = U(u, (T) => T.setPaneRanges), C = U(u, (T) => T.setRowMeasurements), m = U(u, (T) => T.setColMeasurements), S = U(u, (T) => T.onCellFocused), p = e.length, R = t.length, v = ra(
    () => ({
      TopLeft: {
        startRowIdx: 0,
        endRowIdx: n,
        startColIdx: 0,
        endColIdx: a
      },
      TopCenter: {
        startRowIdx: 0,
        endRowIdx: n,
        startColIdx: a,
        endColIdx: R - d
      },
      TopRight: {
        startRowIdx: 0,
        endRowIdx: n,
        startColIdx: R - d,
        endColIdx: R
      },
      Left: {
        startRowIdx: n,
        endRowIdx: p - i,
        startColIdx: 0,
        endColIdx: a
      },
      Center: {
        startRowIdx: n,
        endRowIdx: p - i,
        startColIdx: a,
        endColIdx: R - d
      },
      Right: {
        startRowIdx: n,
        endRowIdx: p - i,
        startColIdx: R - d,
        endColIdx: R
      },
      BottomLeft: {
        startRowIdx: p - i,
        endRowIdx: p,
        startColIdx: 0,
        endColIdx: a
      },
      BottomCenter: {
        startRowIdx: p - i,
        endRowIdx: p,
        startColIdx: a,
        endColIdx: R - d
      },
      BottomRight: {
        startRowIdx: p - i,
        endRowIdx: p,
        startColIdx: R - d,
        endColIdx: R
      }
    }),
    [n, a, d, p, R, i]
  );
  Te(() => {
    S == null || S(h);
  }, [h]), Te(() => {
    r == null || r.forEach((T) => {
      const B = J(I, T);
      Be(T) || (B.startRowIdx < v.TopCenter.endRowIdx && B.endRowIdx > v.TopCenter.endRowIdx, B.endRowIdx > v.BottomCenter.startRowIdx && B.startRowIdx < v.BottomCenter.startRowIdx, B.startColIdx < v.Left.endColIdx && B.endColIdx > v.Left.endColIdx, B.endColIdx > v.Right.startColIdx && B.startColIdx < v.Right.startColIdx);
    }), f(v);
  }, [v]);
  const [y, _] = Kt({
    topRows: [],
    bottomRows: [],
    leftColumns: [],
    rightColumns: []
  }), A = qe(null), w = qe(
    new ResizeObserver(() => {
      const T = E(), B = L();
      C(T), m(B), _(() => ({
        topRows: fi(T, n, "forward"),
        bottomRows: fi(T, i, "backward"),
        leftColumns: xi(B, a, "forward"),
        rightColumns: xi(B, d, "backward")
      }));
    })
  );
  Te(() => {
    if (!A.current)
      return;
    const T = w.current;
    return T.observe(A.current), () => T.disconnect();
  }, []);
  const E = () => {
    if (p === 0 || !A.current)
      return [];
    const T = parseFloat(window.getComputedStyle(A.current).gap ?? "0"), B = [];
    let H = 0, M = 0;
    do {
      const V = I.getCellByIndexes(H, M);
      if (!V) {
        M++;
        continue;
      }
      const Q = A.current.getElementsByClassName(
        `rgRowIdx-${V.rowIndex} rgColIdx-${V.colIndex}`
      )[0];
      if (Q) {
        const be = Q.getBoundingClientRect().height, Xe = H === 0 ? T : B[H - 1].offsetTop + B[H - 1].height + T;
        B.push({ height: be, offsetTop: Xe }), M = 0, H++, w.current.observe(Q);
        continue;
      }
      M++;
    } while (H < p && M < R);
    return B;
  }, L = () => {
    if (R === 0 || !A.current)
      return [];
    const T = parseFloat(window.getComputedStyle(A.current).gap ?? "0"), B = [];
    let H = 0, M = 0;
    do {
      const V = I.getCellByIndexes(M, H);
      if (!V) {
        M++;
        continue;
      }
      const Q = A.current.getElementsByClassName(
        `rgColIdx-${V.colIndex} rgRowIdx-${V.rowIndex}`
      )[0];
      if (Q) {
        const be = Q.getBoundingClientRect().width, Xe = H === 0 ? T : B[H - 1].offsetLeft + B[H - 1].width + T;
        B.push({ width: be, offsetLeft: Xe }), M = 0, H++, w.current.observe(Q);
        continue;
      }
      M++;
    } while (H < R && M < p);
    return B;
  }, j = x.paneContainer.top.background, F = x.paneContainer.bottom.background, W = x.paneContainer.left.background, Y = x.paneContainer.right.background;
  return /* @__PURE__ */ N(
    "div",
    {
      css: {
        display: "flex",
        userSelect: "none",
        ".rgCellContainer": {
          paddingTop: x.cellContainer.padding.top,
          paddingLeft: x.cellContainer.padding.left,
          paddingBottom: x.cellContainer.padding.bottom,
          paddingRight: x.cellContainer.padding.right,
          backgroundColor: x.cellContainer.background
        }
      },
      children: /* @__PURE__ */ Vt(
        "div",
        {
          className: "rgGridContent",
          style: {
            display: "grid",
            gridTemplateColumns: t.map(({ width: T, minWidth: B }) => {
              const H = Nn(T), M = Nn(B ?? 0);
              return H < M ? `${M}px` : `${H}px`;
            }).join(" "),
            gridTemplateRows: e.map(({ height: T }) => typeof T == "number" ? `${T}px` : T).join(" "),
            gap: x.gap.width,
            backgroundColor: x.gap.color,
            padding: x.gap.width
          },
          ref: A,
          children: [
            /* @__PURE__ */ N(At, { paneName: "Center", gridContentRange: v.Center }),
            /* @__PURE__ */ N(
              Fr,
              {
                paneShadowName: "Bottom",
                gridContentRange: { ...v.BottomCenter, startColIdx: 0, endColIdx: R },
                shouldRender: i > 0 && !!x.paneContainer.bottom.boxShadow
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "BottomCenter",
                gridContentRange: v.BottomCenter,
                stickyOffsets: y,
                getCellOffset: (T, B, H) => ({
                  position: "sticky",
                  ...F && { backgroundColor: F },
                  bottom: y.bottomRows.at(-T - H)
                }),
                shouldRender: i > 0
              }
            ),
            /* @__PURE__ */ N(
              Fr,
              {
                paneShadowName: "Top",
                gridContentRange: { ...v.TopCenter, startColIdx: 0, endColIdx: R },
                shouldRender: n > 0 && !!x.paneContainer.top.boxShadow
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "TopCenter",
                gridContentRange: v.TopCenter,
                stickyOffsets: y,
                getCellOffset: (T) => ({
                  position: "sticky",
                  ...j && { backgroundColor: j },
                  top: y.topRows[T]
                }),
                shouldRender: n > 0
              }
            ),
            /* @__PURE__ */ N(
              Fr,
              {
                paneShadowName: "Right",
                gridContentRange: { ...v.Right, startRowIdx: 0, endRowIdx: p },
                shouldRender: d > 0 && !!x.paneContainer.right.boxShadow
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "Right",
                gridContentRange: v.Right,
                stickyOffsets: y,
                getCellOffset: (T, B, H, M) => ({
                  position: "sticky",
                  ...Y && { backgroundColor: Y },
                  right: y.rightColumns.at(-B - M)
                }),
                shouldRender: d > 0
              }
            ),
            /* @__PURE__ */ N(
              Fr,
              {
                paneShadowName: "Left",
                gridContentRange: { ...v.Left, startRowIdx: 0, endRowIdx: p },
                shouldRender: a > 0 && !!x.paneContainer.left.boxShadow
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "Left",
                gridContentRange: v.Left,
                stickyOffsets: y,
                getCellOffset: (T, B) => ({
                  position: "sticky",
                  ...W && { backgroundColor: W },
                  left: y.leftColumns[B]
                }),
                shouldRender: a > 0
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "BottomRight",
                gridContentRange: v.BottomRight,
                stickyOffsets: y,
                getCellOffset: (T, B, H, M) => ({
                  position: "sticky",
                  ...F && { backgroundColor: F },
                  bottom: y.bottomRows.at(-T - H),
                  right: y.rightColumns.at(-B - M)
                }),
                shouldRender: i > 0 && d > 0
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "BottomLeft",
                gridContentRange: v.BottomLeft,
                stickyOffsets: y,
                getCellOffset: (T, B, H) => ({
                  position: "sticky",
                  ...F && { backgroundColor: F },
                  bottom: y.bottomRows.at(-T - H),
                  left: y.leftColumns[B]
                }),
                shouldRender: i > 0 && a > 0
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "TopRight",
                gridContentRange: v.TopRight,
                stickyOffsets: y,
                getCellOffset: (T, B, H, M) => ({
                  position: "sticky",
                  ...j && { backgroundColor: j },
                  top: y.topRows[T],
                  right: y.rightColumns.at(-B - M)
                }),
                shouldRender: n > 0 && d > 0
              }
            ),
            /* @__PURE__ */ N(
              At,
              {
                paneName: "TopLeft",
                gridContentRange: v.TopLeft,
                stickyOffsets: y,
                getCellOffset: (T, B) => ({
                  position: "sticky",
                  ...j && { backgroundColor: j },
                  top: y.topRows[T],
                  left: y.leftColumns[B]
                }),
                shouldRender: n > 0 && a > 0
              }
            )
          ]
        }
      )
    }
  );
}, od = () => {
  const e = It(), t = U(e, (d) => d.lineOrientation), r = U(e, (d) => d.linePosition), n = U(e, (d) => d.reactGridRef), i = mn(), a = t === "vertical";
  return /* @__PURE__ */ N(
    "div",
    {
      className: `rg-line ${a ? "rg-line-vertical" : "rg-line-horizontal"}`,
      style: {
        position: "absolute",
        height: a ? n == null ? void 0 : n.clientHeight : i.line.size,
        top: a ? 0 : r,
        left: a ? r : 0,
        width: a ? i.line.size : n == null ? void 0 : n.scrollWidth,
        backgroundColor: i.line.backgroundColor,
        pointerEvents: "none"
      }
    }
  );
}, id = () => {
  const e = It(), t = U(e, (u) => u.lineOrientation), r = U(e, (u) => u.shadowPosition), n = U(e, (u) => u.shadowSize), i = U(e, (u) => u.reactGridRef), a = mn(), d = t === "vertical";
  return /* @__PURE__ */ N(
    "div",
    {
      className: `rg-line ${d ? "rg-shadow-vertical" : "rg-shadow-horizontal"}`,
      style: {
        position: "absolute",
        height: d ? i == null ? void 0 : i.clientHeight : n,
        top: d ? 0 : r,
        left: d ? r : 0,
        width: d ? n : i == null ? void 0 : i.scrollWidth,
        backgroundColor: a.shadow.backgroundColor,
        pointerEvents: "none"
      }
    }
  );
}, ad = ({ rowIdx: e, colIdx: t }) => {
  const r = It(), n = U(r, (i) => i.changedFocusedLocation);
  return Te(() => {
    var i;
    n && ((i = oe(r, n.rowIndex, n.colIndex)) == null || i.focus());
  }, [n]), /* @__PURE__ */ N("div", { style: { position: "absolute", bottom: 0, right: "50%" }, children: /* @__PURE__ */ N(
    "input",
    {
      onKeyDown: (i) => {
        i.key === "Tab" && i.preventDefault();
      },
      className: `rgHiddenFocusTarget rgFocusRowIdx-${e} rgFocusColIdx-${t}`,
      style: { width: 1, height: 1, opacity: 0, cursor: "default" },
      inputMode: "none"
    }
  ) });
}, ld = () => {
  const e = mn(), t = It(), r = Qr(), n = U(t, (f) => f.resizingColIdx), i = U(t, (f) => f.columns), a = U(t, (f) => f.shadowSize), d = U(t, (f) => f.onResizeColumn), u = U(t, (f) => f.setCurrentBehavior), I = U(t, (f) => f.setResizingColIdx), x = i[r.realColumnIndex];
  return n === void 0 && d && (x == null ? void 0 : x.resizable) && !a && /* @__PURE__ */ N(
    "div",
    {
      className: "rg-resize-column",
      onPointerDown: () => {
        I(r.realColumnIndex), u(ki);
      },
      css: {
        cursor: "col-resize",
        ...e.resizeColumn.default,
        "&:hover": {
          ...e.resizeColumn.hover
        }
      }
    }
  );
}, To = ({
  children: e,
  onStringValueRequested: t,
  onStringValueReceived: r,
  ...n
}) => {
  const { className: i, style: a } = n, d = Qr(), u = It(), I = U(u, (C) => C.enableColumnSelectionOnFirstRow), x = U(u, (C) => C.enableRowSelectionOnFirstColumn), h = d.isFocused || d.realRowIndex === 0 && I || // if column selection is enabled on first row
  d.realColumnIndex === 0 && x;
  return U(u, (C) => C.cellsLookup).set(`${d.realRowIndex} ${d.realColumnIndex}`, {
    rowIndex: d.realRowIndex,
    colIndex: d.realColumnIndex,
    onStringValueRequested: t,
    onStringValueReceived: r
  }), /* @__PURE__ */ Vt(
    "div",
    {
      ...n,
      className: `rgCellContainer rgRowIdx-${d.realRowIndex} rgColIdx-${d.realColumnIndex} ${i ?? ""}`,
      style: {
        minHeight: 0,
        padding: ".2rem",
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        outline: "none",
        overflow: "hidden",
        touchAction: h ? "none" : "auto",
        ...a,
        ...d.containerStyle,
        ...(a == null ? void 0 : a.backgroundColor) && { backgroundColor: a.backgroundColor }
      },
      children: [
        d.realRowIndex === 0 && /* @__PURE__ */ N(ld, {}),
        e,
        /* @__PURE__ */ N(ad, { colIdx: d.realColumnIndex, rowIdx: d.realRowIndex })
      ]
    }
  );
}, dd = ({ value: e, style: t }) => /* @__PURE__ */ N(To, { onStringValueRequested: () => (e == null ? void 0 : e.toString()) || "", onStringValueReceived: () => {
}, style: t, children: e }), sd = (e, t, r) => {
  const n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  r({ setCell: (I, x, h, f, { ...C }) => {
    if (I === -1)
      throw new Error(`Row with id "${I}" isn't defined in rows array`);
    if (x === -1)
      throw new Error(`Column with id "${x}" isn't defined in columns array`);
    if (n.has(`${I} ${x}`)) {
      process.env.NODE_ENV;
      return;
    }
    const m = {
      rowIndex: I,
      colIndex: x,
      Template: h,
      props: f,
      ...Object.fromEntries(Object.entries(C).filter(([R, v]) => v !== void 0))
    }, S = C.rowSpan ?? 1, p = C.colSpan ?? 1;
    for (let R = 0; R < S; R++) {
      const v = I + R;
      for (let y = 0; y < p; y++) {
        const _ = x + y;
        if (R === 0 && y === 0)
          continue;
        const A = {
          originRowIndex: I,
          originColIndex: x
        };
        i.set(`${v} ${_}`, {}), n.set(`${v} ${_}`, A);
      }
    }
    i.set(`${I} ${x}`, {}), n.set(`${I} ${x}`, m);
  } });
  const d = Math.max(...Array.from(n.values()).map((I) => I.rowIndex ?? -1)), u = Math.max(...Array.from(n.values()).map((I) => I.colIndex ?? -1));
  for (let I = 0; I <= d; I++)
    for (let x = 0; x <= u; x++) {
      const h = `${I} ${x}`;
      n.has(h) || n.set(h, {
        rowIndex: I,
        colIndex: x,
        Template: dd,
        props: {
          value: ""
        }
      });
    }
  return {
    cellsLookup: i,
    cells: n,
    rows: cd(d, e),
    columns: ud(u, t)
  };
}, cd = (e, t) => {
  const r = /* @__PURE__ */ new Map();
  return t && t.forEach((n) => {
    r.set(n.rowIndex, n);
  }), Array.from({ length: e + 1 }).map((n, i) => {
    const a = r.get(i);
    return {
      rowIndex: i,
      height: (a == null ? void 0 : a.height) ?? 25,
      reorderable: (a == null ? void 0 : a.reorderable) ?? !0
    };
  });
}, ud = (e, t) => {
  const r = /* @__PURE__ */ new Map();
  return t && t.forEach((n) => {
    r.set(n.colIndex, n);
  }), Array.from({ length: e + 1 }).map((n, i) => {
    const a = r.get(i);
    return {
      colIndex: i,
      resizable: (a == null ? void 0 : a.resizable) ?? !0,
      reorderable: (a == null ? void 0 : a.reorderable) ?? !0,
      width: (a == null ? void 0 : a.width) ?? 150,
      minWidth: (a == null ? void 0 : a.minWidth) ?? 150
    };
  });
};
function fd(e, t) {
  const r = qe(), n = qe();
  return Ce(r.current, t) || (r.current = Ao(t), n.current = e()), n.current;
}
const xd = (e, t, r) => {
  Te(() => {
    var n;
    if (t.initialFocusLocation) {
      const { rowIndex: i, colIndex: a } = t.initialFocusLocation;
      if (!e.getCellByIndexes(i, a))
        return;
      e.getCellOrSpanMemberByIndexes(i, a), (n = oe(e.id, i, a)) == null || n.focus();
    }
  }, []);
}, Id = (e, t, r) => {
  Te(() => {
    if (t.initialSelectedRange) {
      t.initialFocusLocation && r && e.getCellByIndexes(
        t.initialFocusLocation.rowIndex,
        t.initialFocusLocation.colIndex
      );
      const n = $i(e, t.initialSelectedRange);
      e.setSelectedArea(n);
    } else
      return;
  }, []);
};
var Re = [];
for (var so = 0; so < 256; ++so)
  Re.push((so + 256).toString(16).slice(1));
function hd(e, t = 0) {
  return (Re[e[t + 0]] + Re[e[t + 1]] + Re[e[t + 2]] + Re[e[t + 3]] + "-" + Re[e[t + 4]] + Re[e[t + 5]] + "-" + Re[e[t + 6]] + Re[e[t + 7]] + "-" + Re[e[t + 8]] + Re[e[t + 9]] + "-" + Re[e[t + 10]] + Re[e[t + 11]] + Re[e[t + 12]] + Re[e[t + 13]] + Re[e[t + 14]] + Re[e[t + 15]]).toLowerCase();
}
var Hr, pd = new Uint8Array(16);
function gd() {
  if (!Hr && (Hr = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Hr))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Hr(pd);
}
var wd = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const Ii = {
  randomUUID: wd
};
function Cd(e, t, r) {
  if (Ii.randomUUID && !t && !e)
    return Ii.randomUUID();
  e = e || {};
  var n = e.random || (e.rng || gd)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, t) {
    r = r || 0;
    for (var i = 0; i < 16; ++i)
      t[r + i] = n[i];
    return t;
  }
  return hd(n);
}
const Rd = (e, t, r) => {
  Te(() => {
    e.setExternalData({ ...r });
  }, [r]), Te(() => {
    Ce(t.rows, e.rows) || e.setExternalData({ rows: t.rows });
  }, [t.rows]), Te(() => {
    Ce(t.columns, e.columns) || e.setExternalData({ columns: t.columns });
  }, [t.columns]), Te(() => {
    Ce(t.cells, e.cells) || e.setExternalData({ cells: t.cells });
  }, [t.cells]);
}, hi = qt(), vd = ({
  id: e,
  stickyTopRows: t,
  stickyBottomRows: r,
  stickyLeftColumns: n,
  stickyRightColumns: i,
  rows: a,
  columns: d,
  cells: u,
  ...I
}) => {
  var R;
  const x = qe(e ?? `rg-${Cd()}`), h = fd(() => sd(a, d, ({ setCell: v }) => {
    u.forEach((y) => {
      if (y === null)
        return;
      const { Template: _, rowIndex: A, colIndex: w, props: E, ...L } = y;
      v(A, w, _, E, L);
    });
  }), [a, d, u]);
  jl(x.current, {
    ...I,
    ...h
  });
  const f = Xt()[x.current].getState();
  Rd(f, h, I), Id(f, I, hi), xd(f, I);
  const C = U(x.current, (v) => v.currentBehavior), m = U(x.current, (v) => v.linePosition), [S, p] = Kt(!1);
  return hi && !S && h.rows.length * h.columns.length > 25e3 ? /* @__PURE__ */ Vt(vo, { children: [
    /* @__PURE__ */ N("h1", { children: "You're about to render a huge grid!" }),
    /* @__PURE__ */ N("p", { children: "The grid you provided exceeds 25 000 cells. You might experience performance problems. This message is displayed only in development environment." }),
    /* @__PURE__ */ N("p", { children: "Are you sure you want to render it all?" }),
    /* @__PURE__ */ N("button", { onClick: () => p(!0), children: "I understand, proceed anyway." })
  ] }) : /* @__PURE__ */ N(Xl, { id: x.current, children: /* @__PURE__ */ N(ol, { children: /* @__PURE__ */ Vt(ql, { reactGridId: x.current, style: { position: "relative", ...(R = I.styles) == null ? void 0 : R.gridWrapper }, children: [
    /* @__PURE__ */ N(
      rd,
      {
        rows: h.rows,
        columns: h.columns,
        cells: h.cells,
        stickyTopRows: t ?? 0,
        stickyBottomRows: r ?? 0,
        stickyLeftColumns: n ?? 0,
        stickyRightColumns: i ?? 0
      }
    ),
    m !== void 0 && /* @__PURE__ */ N(od, {}),
    po(C.id) && /* @__PURE__ */ N(id, {})
  ] }) }) });
}, Xi = (e, t) => {
  const [r, n] = Kt(0);
  return { handleDoubleTouch: () => {
    if (!e.isFocused)
      return;
    const a = (/* @__PURE__ */ new Date()).getTime(), d = a - r;
    d < 300 && d > 0 && t(!0), n(a);
  } };
}, md = (e, t = []) => {
  const n = [...[
    "Shift",
    "Alt",
    // Modifiers
    "ArrowLeft",
    "ArrowRight",
    "ArrowUp",
    "ArrowDown",
    // Arrow keys
    " ",
    // Space key
    "Tab",
    "PageDown",
    "PageUp",
    "Home",
    "End",
    "Insert",
    "Delete",
    "Backspace",
    "Escape",
    "CapsLock",
    "Enter",
    // Other keys
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12"
    // Function keys
  ], ...t], i = e.ctrlKey || e.metaKey;
  return !(n.includes(e.key) || n.some((d) => e[d]) || i);
}, bd = ({ text: e, onTextChanged: t, style: r }) => {
  const n = Qr(), i = qe(null), [a, d] = Kt(!1), [u, I] = Kt(e || ""), x = qe(!1), { handleDoubleTouch: h } = Xi(n, d);
  return Te(() => {
    I(e);
  }, [e]), /* @__PURE__ */ N(
    To,
    {
      onStringValueRequested: () => e,
      onStringValueReceived: (f) => t == null ? void 0 : t(f),
      onTouchEnd: h,
      style: r,
      onDoubleClick: () => {
        n.isFocused && (I(e || ""), d(!0));
      },
      onKeyDown: (f) => {
        !a && md(f, []) ? (f.stopPropagation(), I(""), d(!0)) : !a && !n.isSelected && (f.key === "Enter" || f.key === "F2") && (f.stopPropagation(), I(e || ""), d(!0));
      },
      children: a ? /* @__PURE__ */ N(
        "input",
        {
          className: "rg-input",
          value: u,
          onChange: (f) => I(f.currentTarget.value),
          onBlur: (f) => {
            x.current || t == null || t(f.currentTarget.value), d(!1), x.current && (x.current = !1);
          },
          onCut: (f) => f.stopPropagation(),
          onCopy: (f) => f.stopPropagation(),
          onPaste: (f) => f.stopPropagation(),
          onPointerDown: (f) => f.stopPropagation(),
          onKeyDown: (f) => {
            ["Escape", "Enter", "Tab"].includes(f.key) || f.stopPropagation(), f.key === "Escape" ? (x.current = !0, d(!1)) : f.key === "Enter" && d(!1);
          },
          autoFocus: !0,
          ref: i
        }
      ) : e
    }
  );
}, Ad = ({
  value: e,
  style: t,
  onValueChanged: r,
  validator: n,
  errorMessage: i,
  hideZero: a,
  allowSeparators: d = !0,
  format: u
}) => {
  const I = e == null ? void 0 : e.toString(), x = Qr(), h = qe(null), [f, C] = Kt(!1), [m, S] = Kt(I || "0"), p = qe(!1), { handleDoubleTouch: R } = Xi(x, C), v = n ? n(Number(e)) : !0, y = () => Number.isNaN(Number(e)) || a && e === 0 ? "" : u ? u.format(e) : !v && i ? i : I;
  Te(() => {
    S(I);
  }, [e]);
  const _ = "0123456789", A = [".", ","];
  return /* @__PURE__ */ N(
    To,
    {
      onTouchEnd: R,
      onStringValueRequested: () => I,
      onStringValueReceived: (w) => {
        const E = w === "" ? NaN : Number(w);
        r == null || r(E);
      },
      style: t,
      onDoubleClick: () => {
        x.isFocused && (S(I || "0"), C(!0));
      },
      onKeyDown: (w) => {
        !f && _.includes(w.key) || d && A.includes(w.key) ? (S(""), C(!0)) : !f && !x.isSelected && (w.key === "Enter" || w.key === "F2") && (w.stopPropagation(), S(I || "0"), C(!0));
      },
      children: f ? /* @__PURE__ */ N(
        "input",
        {
          className: "rg-input",
          value: m,
          onChange: (w) => {
            let E = w.currentTarget.value.replace(d ? /[^0-9,.]/g : /[^0-9]/g, "");
            A.includes(E) && (E = "0" + E), S(E);
          },
          onPointerDown: (w) => w.stopPropagation(),
          onBlur: (w) => {
            if (!p.current) {
              const E = w.currentTarget.value.replace(/,/g, ".");
              r == null || r(Number(E));
            }
            C(!1), p.current && (p.current = !1);
          },
          onCut: (w) => w.stopPropagation(),
          onCopy: (w) => w.stopPropagation(),
          onPaste: (w) => w.stopPropagation(),
          onKeyDown: (w) => {
            ["Escape", "Enter", "Tab"].includes(w.key) || w.stopPropagation(), w.key === "Escape" ? (p.current = !0, C(!1)) : w.key === "Enter" && C(!1);
          },
          autoFocus: !0,
          ref: h
        }
      ) : y()
    }
  );
};
qt();
function _d(e) {
  return Nl(e, (t) => ({
    // Setters
    /**
     * Set the selected area in the ReactGrid.
     * @param range - The range to be selected.
     */
    setSelectedArea: (r) => t.setSelectedArea(r),
    /**
     * Set the focused cell in the ReactGrid.
     * @param location - The id-based location of the cell to be focused.
     */
    setFocusedCell: ({ rowIndex: r, colIndex: n }) => (t.getCellByIndexes(r, n), t.setFocusedLocation(r, n)),
    /**
     * Set the selected columns in the ReactGrid.
     * @param startColId
     * @param endColId
     */
    setSelectedColumns: (r, n) => t.setSelectedColumns(r, n),
    /**
     * Set selected rows in the ReactGrid.
     * @param startRowId
     * @param endRowId
     */
    setSelectedRows: (r, n) => t.setSelectedRows(r, n),
    // Getters
    /**
     * Get the currently focused cell in the ReactGrid.
     * @returns The location of the focused cell.
     */
    getFocusedCell: t.getFocusedCell,
    /**
     * Get the cell at the specified indexes in the ReactGrid.
     * @param rowIndex - The row index of the cell.
     * @param colIndex - The column index of the cell.
     * @returns The cell at the specified indexes.
     */
    getCellByIndexes: t.getCellByIndexes,
    /**
     * Get the cell or span member at the specified indexes in the ReactGrid.
     * @param rowIndex - The row index of the cell.
     * @param colIndex - The column index of the cell.
     * @returns The cell or span member at the specified indexes.
     */
    getCellOrSpanMemberByIndexes: t.getCellOrSpanMemberByIndexes,
    /**
     * Get the pane ranges in the ReactGrid.
     * @returns The pane ranges.
     */
    getPaneRanges: t.getPaneRanges,
    /**
     * Get the cells lookup in the ReactGrid.
     * @returns The cells lookup.
     */
    getCellsLookup: t.getCellsLookup,
    /**
     * Get the selected area in the ReactGrid.
     * @returns The selected area.
     */
    getSelectedArea: t.getSelectedArea,
    /**
     * Get the rows in the ReactGrid.
     * @returns Row[]
     */
    getRows: () => t.rows,
    /**
     * Get the columns in the ReactGrid.
     * @returns Column[]
     */
    getColumns: () => t.columns
  }));
}
export {
  To as CellWrapper,
  dd as NonEditableCell,
  Ad as NumberCell,
  vd as ReactGrid,
  bd as TextCell,
  md as isValidKey,
  Qr as useCellContext,
  Xi as useDoubleTouch,
  _d as useReactGridAPI
};
